<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>é’é¾™é¢æ¿ Bot v5.0 - å¤šç”¨æˆ·APIç‰ˆ</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <style>
    .code-container {
      max-height: 70vh;
      overflow-y: auto;
    }
    .code-container::-webkit-scrollbar {
      width: 8px;
    }
    .code-container::-webkit-scrollbar-track {
      background: #1e293b;
    }
    .code-container::-webkit-scrollbar-thumb {
      background: #475569;
      border-radius: 4px;
    }
    .tab-active {
      border-bottom: 2px solid #3b82f6;
      color: #3b82f6;
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
  <!-- Header -->
  <header class="bg-gradient-to-r from-blue-900 to-purple-900 shadow-lg">
    <div class="max-w-7xl mx-auto px-4 py-6">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
          <span class="text-4xl">ğŸ‰</span>
          <div>
            <h1 class="text-2xl font-bold">é’é¾™é¢æ¿ Telegram Bot</h1>
            <p class="text-blue-200">v5.0 - å¤šç”¨æˆ· API ç‰ˆ</p>
          </div>
        </div>
        <div class="flex flex-wrap gap-2">
          <span class="px-3 py-1 bg-red-600 rounded-full text-sm">ğŸ” ç«¯åˆ°ç«¯åŠ å¯†</span>
          <span class="px-3 py-1 bg-green-600 rounded-full text-sm">ğŸ‘¥ å¤šç”¨æˆ·</span>
          <span class="px-3 py-1 bg-yellow-600 rounded-full text-sm">ğŸ”Œ RESTful API</span>
          <span class="px-3 py-1 bg-blue-600 rounded-full text-sm">Cloudflare Workers</span>
        </div>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="max-w-7xl mx-auto px-4 py-8">
    <!-- Feature Highlights -->
    <section class="mb-8 grid md:grid-cols-3 gap-6">
      <div class="bg-gradient-to-r from-red-900/50 to-orange-900/50 border border-red-700 rounded-xl p-6">
        <h2 class="text-xl font-bold text-red-400 mb-4 flex items-center gap-2">
          <span>ğŸ”</span> å®‰å…¨åŠ å¯†å­˜å‚¨
        </h2>
        <ul class="space-y-2 text-gray-300">
          <li class="flex items-start gap-2">
            <span class="text-red-500">â–¸</span>
            ç”¨æˆ·è®¾ç½® PIN ç ä½œä¸ºåŠ å¯†å¯†é’¥
          </li>
          <li class="flex items-start gap-2">
            <span class="text-red-500">â–¸</span>
            AES-256-GCM åŠ å¯†æ•æ„Ÿå‡­è¯
          </li>
          <li class="flex items-start gap-2">
            <span class="text-red-500">â–¸</span>
            PIN ä¸å­˜å‚¨ï¼Œéƒ¨ç½²è€…æ— æ³•è§£å¯†
          </li>
          <li class="flex items-start gap-2">
            <span class="text-red-500">â–¸</span>
            æ¯æ¬¡ä¼šè¯éœ€éªŒè¯ PIN
          </li>
        </ul>
      </div>
      
      <div class="bg-gradient-to-r from-green-900/50 to-emerald-900/50 border border-green-700 rounded-xl p-6">
        <h2 class="text-xl font-bold text-green-400 mb-4 flex items-center gap-2">
          <span>ğŸ‘¥</span> å¤šç”¨æˆ·ç®¡ç†
        </h2>
        <ul class="space-y-2 text-gray-300">
          <li class="flex items-start gap-2">
            <span class="text-green-500">â–¸</span>
            æ™®é€šç”¨æˆ·å¯è‡ªåŠ©æ·»åŠ é’é¾™é¢æ¿
          </li>
          <li class="flex items-start gap-2">
            <span class="text-green-500">â–¸</span>
            ç”¨æˆ·å¯éšæ—¶åˆ é™¤è‡ªå·±çš„é…ç½®
          </li>
          <li class="flex items-start gap-2">
            <span class="text-green-500">â–¸</span>
            ç®¡ç†å‘˜å¯æŸ¥çœ‹/åˆ é™¤/æ‹‰é»‘ç”¨æˆ·
          </li>
          <li class="flex items-start gap-2">
            <span class="text-green-500">â–¸</span>
            ç®¡ç†å‘˜ä½¿ç”¨é»˜è®¤é’é¾™é…ç½®
          </li>
        </ul>
      </div>

      <div class="bg-gradient-to-r from-yellow-900/50 to-amber-900/50 border border-yellow-700 rounded-xl p-6">
        <h2 class="text-xl font-bold text-yellow-400 mb-4 flex items-center gap-2">
          <span>ğŸ”Œ</span> RESTful API
        </h2>
        <ul class="space-y-2 text-gray-300">
          <li class="flex items-start gap-2">
            <span class="text-yellow-500">â–¸</span>
            å®Œæ•´çš„ REST API æ¥å£
          </li>
          <li class="flex items-start gap-2">
            <span class="text-yellow-500">â–¸</span>
            JWT Token è®¤è¯æœºåˆ¶
          </li>
          <li class="flex items-start gap-2">
            <span class="text-yellow-500">â–¸</span>
            æ”¯æŒç¯å¢ƒå˜é‡/ä»»åŠ¡/è®¢é˜…ç­‰
          </li>
          <li class="flex items-start gap-2">
            <span class="text-yellow-500">â–¸</span>
            å¯ä¸å…¶ä»–ç³»ç»Ÿé›†æˆ
          </li>
        </ul>
      </div>
    </section>

    <!-- Architecture -->
    <section class="mb-8">
      <div class="bg-gray-800 rounded-xl p-6">
        <h2 class="text-xl font-bold text-blue-400 mb-4">ğŸ—ï¸ ç³»ç»Ÿæ¶æ„</h2>
        <div class="grid md:grid-cols-3 gap-4">
          <div class="bg-gray-700 rounded-lg p-4 text-center">
            <div class="text-3xl mb-2">ğŸ‘¤</div>
            <h3 class="font-bold text-yellow-400">æ™®é€šç”¨æˆ·</h3>
            <p class="text-sm text-gray-400 mt-2">è‡ªåŠ©æ·»åŠ é’é¾™é¢æ¿<br>PIN åŠ å¯†å­˜å‚¨å‡­è¯<br>å¯åˆ é™¤è‡ªå·±é…ç½®</p>
          </div>
          <div class="bg-gray-700 rounded-lg p-4 text-center">
            <div class="text-3xl mb-2">ğŸ‘‘</div>
            <h3 class="font-bold text-purple-400">ç®¡ç†å‘˜</h3>
            <p class="text-sm text-gray-400 mt-2">ä½¿ç”¨é»˜è®¤é’é¾™é…ç½®<br>ç®¡ç†æ‰€æœ‰ç”¨æˆ·<br>å¯æ‹‰é»‘è¿è§„ç”¨æˆ·</p>
          </div>
          <div class="bg-gray-700 rounded-lg p-4 text-center">
            <div class="text-3xl mb-2">ğŸ”’</div>
            <h3 class="font-bold text-red-400">KV å­˜å‚¨</h3>
            <p class="text-sm text-gray-400 mt-2">åŠ å¯†å­˜å‚¨ç”¨æˆ·å‡­è¯<br>é»‘åå•ç®¡ç†<br>ç”¨æˆ·å…ƒæ•°æ®</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Tabs -->
    <div class="flex gap-4 border-b border-gray-700 mb-6 overflow-x-auto">
      <button onclick="showTab('flow')" id="tab-flow" class="px-4 py-2 font-medium tab-active whitespace-nowrap">
        ğŸ“Š ç”¨æˆ·æµç¨‹
      </button>
      <button onclick="showTab('api')" id="tab-api" class="px-4 py-2 font-medium text-gray-400 hover:text-gray-200 whitespace-nowrap">
        ğŸ”Œ API æ–‡æ¡£
      </button>
      <button onclick="showTab('full')" id="tab-full" class="px-4 py-2 font-medium text-gray-400 hover:text-gray-200 whitespace-nowrap">
        ğŸ“œ å®Œæ•´ä»£ç 
      </button>
      <button onclick="showTab('usage')" id="tab-usage" class="px-4 py-2 font-medium text-gray-400 hover:text-gray-200 whitespace-nowrap">
        ğŸ“– éƒ¨ç½²è¯´æ˜
      </button>
    </div>

    <!-- Flow Tab -->
    <div id="content-flow" class="space-y-6">
      <!-- New User Flow -->
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gray-700 px-4 py-3">
          <h3 class="font-semibold text-green-400">ğŸ†• æ–°ç”¨æˆ·æµç¨‹</h3>
        </div>
        <div class="p-4">
          <div class="flex flex-wrap gap-2 items-center text-sm">
            <span class="px-3 py-2 bg-blue-900 rounded-lg">è®¿é—® Bot</span>
            <span class="text-gray-500">â†’</span>
            <span class="px-3 py-2 bg-yellow-900 rounded-lg">æç¤ºæ·»åŠ é’é¾™</span>
            <span class="text-gray-500">â†’</span>
            <span class="px-3 py-2 bg-green-900 rounded-lg">è¾“å…¥ URL</span>
            <span class="text-gray-500">â†’</span>
            <span class="px-3 py-2 bg-green-900 rounded-lg">è¾“å…¥ Client ID</span>
            <span class="text-gray-500">â†’</span>
            <span class="px-3 py-2 bg-green-900 rounded-lg">è¾“å…¥ Secret</span>
            <span class="text-gray-500">â†’</span>
            <span class="px-3 py-2 bg-red-900 rounded-lg">è®¾ç½® PIN</span>
            <span class="text-gray-500">â†’</span>
            <span class="px-3 py-2 bg-purple-900 rounded-lg">åŠ å¯†ä¿å­˜</span>
            <span class="text-gray-500">â†’</span>
            <span class="px-3 py-2 bg-blue-900 rounded-lg">å¼€å§‹ä½¿ç”¨</span>
          </div>
        </div>
      </div>

      <!-- Return User Flow -->
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gray-700 px-4 py-3">
          <h3 class="font-semibold text-blue-400">ğŸ”„ è€ç”¨æˆ·æµç¨‹</h3>
        </div>
        <div class="p-4">
          <div class="flex flex-wrap gap-2 items-center text-sm">
            <span class="px-3 py-2 bg-blue-900 rounded-lg">è®¿é—® Bot</span>
            <span class="text-gray-500">â†’</span>
            <span class="px-3 py-2 bg-red-900 rounded-lg">è¾“å…¥ PIN è§£é”</span>
            <span class="text-gray-500">â†’</span>
            <span class="px-3 py-2 bg-purple-900 rounded-lg">è§£å¯†å‡­è¯</span>
            <span class="text-gray-500">â†’</span>
            <span class="px-3 py-2 bg-green-900 rounded-lg">æ­£å¸¸ä½¿ç”¨</span>
          </div>
          <p class="text-gray-400 text-sm mt-3">ğŸ’¡ ä¼šè¯æœ‰æ•ˆæœŸå†…æ— éœ€é‡å¤è¾“å…¥ PINï¼ˆå¯é…ç½®è¶…æ—¶æ—¶é—´ï¼‰</p>
        </div>
      </div>

      <!-- Admin Flow -->
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gray-700 px-4 py-3">
          <h3 class="font-semibold text-purple-400">ğŸ‘‘ ç®¡ç†å‘˜åŠŸèƒ½</h3>
        </div>
        <div class="p-4 grid md:grid-cols-2 gap-4">
          <div class="bg-gray-700 rounded-lg p-4">
            <h4 class="font-semibold text-yellow-400 mb-2">ğŸ“‹ ç”¨æˆ·ç®¡ç†</h4>
            <ul class="text-sm text-gray-300 space-y-1">
              <li>â€¢ æŸ¥çœ‹æ‰€æœ‰å·²æ³¨å†Œç”¨æˆ·</li>
              <li>â€¢ æŸ¥çœ‹ç”¨æˆ·åŸºæœ¬ä¿¡æ¯ï¼ˆä¸å«å‡­è¯ï¼‰</li>
              <li>â€¢ åˆ é™¤ç”¨æˆ·é…ç½®</li>
              <li>â€¢ æ‹‰é»‘ç”¨æˆ·ï¼ˆç¦æ­¢ä½¿ç”¨ï¼‰</li>
              <li>â€¢ è§£é™¤æ‹‰é»‘</li>
            </ul>
          </div>
          <div class="bg-gray-700 rounded-lg p-4">
            <h4 class="font-semibold text-green-400 mb-2">ğŸ”§ é»˜è®¤é…ç½®</h4>
            <ul class="text-sm text-gray-300 space-y-1">
              <li>â€¢ ä½¿ç”¨ç¯å¢ƒå˜é‡ä¸­çš„é’é¾™é…ç½®</li>
              <li>â€¢ æ— éœ€ PIN éªŒè¯</li>
              <li>â€¢ å®Œæ•´åŠŸèƒ½æƒé™</li>
              <li>â€¢ æ–°å¢ /users å‘½ä»¤</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Security -->
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gray-700 px-4 py-3">
          <h3 class="font-semibold text-red-400">ğŸ” åŠ å¯†å®‰å…¨è¯´æ˜</h3>
        </div>
        <div class="p-4">
          <pre class="rounded-lg text-sm"><code class="language-javascript">// åŠ å¯†æµç¨‹è¯´æ˜
// 1. ç”¨æˆ·è®¾ç½® 6 ä½æ•°å­— PINï¼ˆä¸å­˜å‚¨åŸå§‹ PINï¼‰
// 2. ä½¿ç”¨ PBKDF2 ä» PIN + UserID + Salt æ´¾ç”Ÿ 256 ä½å¯†é’¥
// 3. ä½¿ç”¨ AES-256-GCM åŠ å¯†é’é¾™å‡­è¯
// 4. å­˜å‚¨: { salt, iv, encryptedData, authTag }
// 5. PIN éªŒè¯: å°è¯•è§£å¯†ï¼ŒæˆåŠŸåˆ™ PIN æ­£ç¡®

// ä¸ºä»€ä¹ˆéƒ¨ç½²è€…æ— æ³•è§£å¯†ï¼Ÿ
// - PIN åªå­˜åœ¨äºç”¨æˆ·è„‘ä¸­ï¼Œä¸å­˜å‚¨
// - æ²¡æœ‰ PIN æ— æ³•æ´¾ç”Ÿæ­£ç¡®çš„å¯†é’¥
// - AES-GCM æä¾›è®¤è¯åŠ å¯†ï¼Œé”™è¯¯å¯†é’¥ä¼šè§£å¯†å¤±è´¥
// - å³ä½¿æ‹¿åˆ° KV æ•°æ®ä¹Ÿæ— æ³•æš´åŠ›ç ´è§£ï¼ˆPBKDF2 iterationsï¼‰</code></pre>
        </div>
      </div>
    </div>

    <!-- API Documentation Tab -->
    <div id="content-api" class="hidden space-y-6">
      <!-- API Overview -->
      <div class="bg-gray-800 rounded-xl p-6">
        <h2 class="text-xl font-bold text-yellow-400 mb-4">ğŸ”Œ API æ¦‚è§ˆ</h2>
        <p class="text-gray-300 mb-4">æ‰€æœ‰ API è¯·æ±‚éœ€è¦åœ¨ Header ä¸­æºå¸¦è®¤è¯ Tokenï¼š</p>
        <pre class="bg-gray-900 p-4 rounded-lg text-sm overflow-x-auto"><code class="language-bash">Authorization: Bearer &lt;your_token&gt;</code></pre>
        <p class="text-gray-400 text-sm mt-3">Base URL: <code class="bg-gray-700 px-2 py-1 rounded">https://your-worker.workers.dev/api</code></p>
      </div>

      <!-- Authentication -->
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gradient-to-r from-red-900 to-orange-900 px-4 py-3">
          <h3 class="font-semibold text-white">ğŸ” è®¤è¯æ¥å£</h3>
        </div>
        <div class="p-4 space-y-4">
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-green-600 rounded text-xs font-bold">POST</span>
              <code class="text-yellow-400">/api/auth/token</code>
            </div>
            <p class="text-gray-400 text-sm mb-3">è·å–è®¿é—® Tokenï¼ˆæ™®é€šç”¨æˆ·ï¼‰</p>
            <pre class="bg-gray-900 p-3 rounded text-sm overflow-x-auto"><code class="language-json">{
  "user_id": 123456789,
  "pin": "123456"
}</code></pre>
            <p class="text-gray-500 text-xs mt-2">è¿”å›: <code>{ "token": "eyJ...", "expires_in": 3600 }</code></p>
          </div>
          
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-green-600 rounded text-xs font-bold">POST</span>
              <code class="text-yellow-400">/api/auth/admin</code>
            </div>
            <p class="text-gray-400 text-sm mb-3">ç®¡ç†å‘˜è®¤è¯ï¼ˆä½¿ç”¨ API_SECRETï¼‰</p>
            <pre class="bg-gray-900 p-3 rounded text-sm overflow-x-auto"><code class="language-json">{
  "secret": "your_api_secret"
}</code></pre>
          </div>
        </div>
      </div>

      <!-- Environment Variables API -->
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gradient-to-r from-green-900 to-emerald-900 px-4 py-3">
          <h3 class="font-semibold text-white">ğŸ”‘ ç¯å¢ƒå˜é‡ API</h3>
        </div>
        <div class="p-4 space-y-4">
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-blue-600 rounded text-xs font-bold">GET</span>
              <code class="text-yellow-400">/api/envs</code>
            </div>
            <p class="text-gray-400 text-sm">è·å–æ‰€æœ‰ç¯å¢ƒå˜é‡åˆ—è¡¨</p>
          </div>
          
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-green-600 rounded text-xs font-bold">POST</span>
              <code class="text-yellow-400">/api/envs</code>
            </div>
            <p class="text-gray-400 text-sm mb-3">æ·»åŠ ç¯å¢ƒå˜é‡</p>
            <pre class="bg-gray-900 p-3 rounded text-sm overflow-x-auto"><code class="language-json">{
  "name": "MY_VAR",
  "value": "my_value",
  "remarks": "å¤‡æ³¨è¯´æ˜"
}</code></pre>
          </div>
          
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-yellow-600 rounded text-xs font-bold">PUT</span>
              <code class="text-yellow-400">/api/envs/:id</code>
            </div>
            <p class="text-gray-400 text-sm mb-3">æ›´æ–°ç¯å¢ƒå˜é‡</p>
            <pre class="bg-gray-900 p-3 rounded text-sm overflow-x-auto"><code class="language-json">{
  "name": "MY_VAR",
  "value": "new_value"
}</code></pre>
          </div>
          
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-red-600 rounded text-xs font-bold">DELETE</span>
              <code class="text-yellow-400">/api/envs/:id</code>
            </div>
            <p class="text-gray-400 text-sm">åˆ é™¤ç¯å¢ƒå˜é‡</p>
          </div>

          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-purple-600 rounded text-xs font-bold">PUT</span>
              <code class="text-yellow-400">/api/envs/:id/enable</code>
            </div>
            <p class="text-gray-400 text-sm">å¯ç”¨ç¯å¢ƒå˜é‡</p>
          </div>

          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-gray-600 rounded text-xs font-bold">PUT</span>
              <code class="text-yellow-400">/api/envs/:id/disable</code>
            </div>
            <p class="text-gray-400 text-sm">ç¦ç”¨ç¯å¢ƒå˜é‡</p>
          </div>
        </div>
      </div>

      <!-- Tasks API -->
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gradient-to-r from-blue-900 to-indigo-900 px-4 py-3">
          <h3 class="font-semibold text-white">ğŸ“‹ ä»»åŠ¡ç®¡ç† API</h3>
        </div>
        <div class="p-4 space-y-4">
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-blue-600 rounded text-xs font-bold">GET</span>
              <code class="text-yellow-400">/api/crons</code>
            </div>
            <p class="text-gray-400 text-sm">è·å–æ‰€æœ‰å®šæ—¶ä»»åŠ¡</p>
          </div>
          
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-green-600 rounded text-xs font-bold">POST</span>
              <code class="text-yellow-400">/api/crons</code>
            </div>
            <p class="text-gray-400 text-sm mb-3">åˆ›å»ºå®šæ—¶ä»»åŠ¡</p>
            <pre class="bg-gray-900 p-3 rounded text-sm overflow-x-auto"><code class="language-json">{
  "name": "æµ‹è¯•ä»»åŠ¡",
  "command": "task test.js",
  "schedule": "0 8 * * *"
}</code></pre>
          </div>
          
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-purple-600 rounded text-xs font-bold">PUT</span>
              <code class="text-yellow-400">/api/crons/:id/run</code>
            </div>
            <p class="text-gray-400 text-sm">ç«‹å³è¿è¡Œä»»åŠ¡</p>
          </div>

          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-orange-600 rounded text-xs font-bold">PUT</span>
              <code class="text-yellow-400">/api/crons/:id/stop</code>
            </div>
            <p class="text-gray-400 text-sm">åœæ­¢è¿è¡Œä¸­çš„ä»»åŠ¡</p>
          </div>

          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-blue-600 rounded text-xs font-bold">GET</span>
              <code class="text-yellow-400">/api/crons/:id/log</code>
            </div>
            <p class="text-gray-400 text-sm">è·å–ä»»åŠ¡æ—¥å¿—</p>
          </div>
        </div>
      </div>

      <!-- Subscriptions API -->
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gradient-to-r from-purple-900 to-pink-900 px-4 py-3">
          <h3 class="font-semibold text-white">ğŸ“¦ è®¢é˜…ç®¡ç† API</h3>
        </div>
        <div class="p-4 space-y-4">
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-blue-600 rounded text-xs font-bold">GET</span>
              <code class="text-yellow-400">/api/subscriptions</code>
            </div>
            <p class="text-gray-400 text-sm">è·å–æ‰€æœ‰è®¢é˜…</p>
          </div>
          
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-green-600 rounded text-xs font-bold">POST</span>
              <code class="text-yellow-400">/api/subscriptions</code>
            </div>
            <p class="text-gray-400 text-sm mb-3">æ·»åŠ è®¢é˜…</p>
            <pre class="bg-gray-900 p-3 rounded text-sm overflow-x-auto"><code class="language-json">{
  "name": "æˆ‘çš„è®¢é˜…",
  "url": "https://github.com/user/repo",
  "schedule": "0 0 * * *",
  "branch": "main"
}</code></pre>
          </div>
        </div>
      </div>

      <!-- Scripts API -->
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gradient-to-r from-cyan-900 to-teal-900 px-4 py-3">
          <h3 class="font-semibold text-white">ğŸ“ è„šæœ¬ç®¡ç† API</h3>
        </div>
        <div class="p-4 space-y-4">
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-blue-600 rounded text-xs font-bold">GET</span>
              <code class="text-yellow-400">/api/scripts</code>
            </div>
            <p class="text-gray-400 text-sm">è·å–è„šæœ¬ç›®å½•æ ‘</p>
          </div>
          
          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-blue-600 rounded text-xs font-bold">GET</span>
              <code class="text-yellow-400">/api/scripts/:filename?path=</code>
            </div>
            <p class="text-gray-400 text-sm">è·å–è„šæœ¬å†…å®¹</p>
          </div>

          <div class="bg-gray-700 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-2">
              <span class="px-2 py-1 bg-green-600 rounded text-xs font-bold">POST</span>
              <code class="text-yellow-400">/api/scripts</code>
            </div>
            <p class="text-gray-400 text-sm mb-3">ä¸Šä¼ /æ›´æ–°è„šæœ¬</p>
            <pre class="bg-gray-900 p-3 rounded text-sm overflow-x-auto"><code class="language-json">{
  "filename": "test.js",
  "content": "console.log('hello');",
  "path": ""
}</code></pre>
          </div>
        </div>
      </div>

      <!-- Code Examples -->
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gradient-to-r from-gray-700 to-gray-600 px-4 py-3">
          <h3 class="font-semibold text-white">ğŸ’» ä»£ç ç¤ºä¾‹</h3>
        </div>
        <div class="p-4 space-y-4">
          <div class="bg-gray-700 rounded-lg p-4">
            <h4 class="text-green-400 font-semibold mb-3">JavaScript / Node.js</h4>
            <pre class="bg-gray-900 p-3 rounded text-sm overflow-x-auto"><code class="language-javascript">// è·å– Token
const authRes = await fetch('https://your-worker.dev/api/auth/token', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ user_id: 123456, pin: '123456' })
});
const { token } = await authRes.json();

// æ·»åŠ ç¯å¢ƒå˜é‡
const res = await fetch('https://your-worker.dev/api/envs', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`
  },
  body: JSON.stringify({
    name: 'MY_COOKIE',
    value: 'abc123',
    remarks: 'æˆ‘çš„Cookie'
  })
});
console.log(await res.json());</code></pre>
          </div>

          <div class="bg-gray-700 rounded-lg p-4">
            <h4 class="text-blue-400 font-semibold mb-3">cURL</h4>
            <pre class="bg-gray-900 p-3 rounded text-sm overflow-x-auto"><code class="language-bash"># è·å– Token
curl -X POST https://your-worker.dev/api/auth/token \
  -H "Content-Type: application/json" \
  -d '{"user_id": 123456, "pin": "123456"}'

# æ·»åŠ ç¯å¢ƒå˜é‡
curl -X POST https://your-worker.dev/api/envs \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{"name": "MY_VAR", "value": "my_value"}'

# è·å–ç¯å¢ƒå˜é‡åˆ—è¡¨
curl https://your-worker.dev/api/envs \
  -H "Authorization: Bearer YOUR_TOKEN"</code></pre>
          </div>

          <div class="bg-gray-700 rounded-lg p-4">
            <h4 class="text-yellow-400 font-semibold mb-3">Python</h4>
            <pre class="bg-gray-900 p-3 rounded text-sm overflow-x-auto"><code class="language-python">import requests

BASE_URL = 'https://your-worker.dev/api'

# è·å– Token
auth_res = requests.post(f'{BASE_URL}/auth/token', json={
    'user_id': 123456,
    'pin': '123456'
})
token = auth_res.json()['token']

headers = {'Authorization': f'Bearer {token}'}

# æ·»åŠ ç¯å¢ƒå˜é‡
res = requests.post(f'{BASE_URL}/envs', json={
    'name': 'MY_VAR',
    'value': 'my_value'
}, headers=headers)
print(res.json())</code></pre>
          </div>
        </div>
      </div>
    </div>

    <!-- Full Code Tab -->
    <div id="content-full" class="hidden">
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gray-700 px-4 py-3 flex items-center justify-between">
          <h3 class="font-semibold">ğŸ“œ å®Œæ•´ä»£ç  (index.ts)</h3>
          <button onclick="copyCode()" class="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm transition">
            ğŸ“‹ å¤åˆ¶ä»£ç 
          </button>
        </div>
        <div class="code-container p-4">
          <pre><code class="language-javascript" id="full-code">// src/index.ts - é’é¾™é¢æ¿ Bot v5.0 å¤šç”¨æˆ· API ç‰ˆ

// ==================== ç±»å‹å®šä¹‰ ====================
interface UserConfig {
  odl_base_url: string;
  ql_client_id: string;
  ql_client_secret: string;
}

interface EncryptedData {
  salt: string;      // Base64
  iv: string;        // Base64
  data: string;      // Base64 encrypted
  tag: string;       // Base64 auth tag
}

interface UserMeta {
  odl_id: number;
  username?: string;
  first_name?: string;
  created_at: number;
  last_active: number;
}

// ==================== å¸¸é‡é…ç½® ====================
var BOT_COMMANDS = [
  { command: "start", description: "å¼€å§‹ä½¿ç”¨" },
  { command: "tasks", description: "ä»»åŠ¡ç®¡ç†" },
  { command: "envs", description: "ç¯å¢ƒå˜é‡" },
  { command: "subs", description: "è®¢é˜…ç®¡ç†" },
  { command: "deps", description: "ä¾èµ–ç®¡ç†" },
  { command: "scripts", description: "è„šæœ¬ç®¡ç†" },
  { command: "myconfig", description: "æˆ‘çš„é…ç½®" },
  { command: "help", description: "å¸®åŠ©ä¿¡æ¯" }
];

var ADMIN_COMMANDS = [
  ...BOT_COMMANDS,
  { command: "users", description: "ç”¨æˆ·ç®¡ç†(ç®¡ç†å‘˜)" }
];

var userStates = new Map();
var userSessions = new Map(); // å­˜å‚¨å·²éªŒè¯ç”¨æˆ·çš„è§£å¯†é…ç½®
var SESSION_TIMEOUT = 30 * 60 * 1000; // 30åˆ†é’Ÿä¼šè¯è¶…æ—¶
var API_TOKEN_EXPIRY = 3600 * 1000; // API Token 1å°æ—¶è¿‡æœŸ

var REQUEST_TIMEOUT = 10000;
var PBKDF2_ITERATIONS = 100000;

// API Token å­˜å‚¨
var apiTokens = new Map(); // token -> { odl_id, config, expiry }

// ==================== åŠ å¯†å·¥å…·å‡½æ•° ====================

// å°†å­—ç¬¦ä¸²è½¬ä¸º ArrayBuffer
function str2ab(str) {
  const encoder = new TextEncoder();
  return encoder.encode(str);
}

// å°† ArrayBuffer è½¬ä¸º Base64
function ab2base64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// å°† Base64 è½¬ä¸º ArrayBuffer
function base642ab(base64) {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes.buffer;
}

// ä» PIN æ´¾ç”ŸåŠ å¯†å¯†é’¥
async function deriveKey(pin, odl_id, salt) {
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    str2ab(pin + "_" + odl_id),
    "PBKDF2",
    false,
    ["deriveBits", "deriveKey"]
  );
  
  return await crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: salt,
      iterations: PBKDF2_ITERATIONS,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}

// åŠ å¯†ç”¨æˆ·é…ç½®
async function encryptConfig(config, pin, odl_id) {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(pin, odl_id, salt);
  
  const plaintext = JSON.stringify(config);
  const encrypted = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv: iv },
    key,
    str2ab(plaintext)
  );
  
  // AES-GCM çš„è¾“å‡ºåŒ…å«å¯†æ–‡å’Œè®¤è¯æ ‡ç­¾
  const encryptedArray = new Uint8Array(encrypted);
  const data = encryptedArray.slice(0, -16);
  const tag = encryptedArray.slice(-16);
  
  return {
    salt: ab2base64(salt),
    iv: ab2base64(iv),
    data: ab2base64(data),
    tag: ab2base64(tag)
  };
}

// è§£å¯†ç”¨æˆ·é…ç½®
async function decryptConfig(encryptedData, pin, odl_id) {
  try {
    const salt = new Uint8Array(base642ab(encryptedData.salt));
    const iv = new Uint8Array(base642ab(encryptedData.iv));
    const data = new Uint8Array(base642ab(encryptedData.data));
    const tag = new Uint8Array(base642ab(encryptedData.tag));
    
    const key = await deriveKey(pin, odl_id, salt);
    
    // é‡æ–°ç»„åˆå¯†æ–‡å’Œæ ‡ç­¾
    const combined = new Uint8Array(data.length + tag.length);
    combined.set(data);
    combined.set(tag, data.length);
    
    const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: iv },
      key,
      combined
    );
    
    const decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decrypted));
  } catch (e) {
    return null; // PIN é”™è¯¯æˆ–æ•°æ®æŸå
  }
}

// ==================== KV å­˜å‚¨æ“ä½œ ====================

// è·å–ç”¨æˆ·åŠ å¯†é…ç½®
async function getUserEncryptedConfig(env, odl_id) {
  const data = await env.USER_CONFIGS.get("config:" + odl_id);
  return data ? JSON.parse(data) : null;
}

// ä¿å­˜ç”¨æˆ·åŠ å¯†é…ç½®
async function saveUserEncryptedConfig(env, odl_id, encryptedConfig, meta) {
  await env.USER_CONFIGS.put("config:" + odl_id, JSON.stringify(encryptedConfig));
  await env.USER_CONFIGS.put("meta:" + odl_id, JSON.stringify(meta));
  
  // æ›´æ–°ç”¨æˆ·åˆ—è¡¨
  const userList = await getUserList(env);
  if (!userList.includes(odl_id)) {
    userList.push(odl_id);
    await env.USER_CONFIGS.put("user_list", JSON.stringify(userList));
  }
}

// åˆ é™¤ç”¨æˆ·é…ç½®
async function deleteUserConfig(env, odl_id) {
  await env.USER_CONFIGS.delete("config:" + odl_id);
  await env.USER_CONFIGS.delete("meta:" + odl_id);
  
  const userList = await getUserList(env);
  const newList = userList.filter(id => id !== odl_id);
  await env.USER_CONFIGS.put("user_list", JSON.stringify(newList));
}

// è·å–ç”¨æˆ·åˆ—è¡¨
async function getUserList(env) {
  const data = await env.USER_CONFIGS.get("user_list");
  return data ? JSON.parse(data) : [];
}

// è·å–ç”¨æˆ·å…ƒæ•°æ®
async function getUserMeta(env, odl_id) {
  const data = await env.USER_CONFIGS.get("meta:" + odl_id);
  return data ? JSON.parse(data) : null;
}

// é»‘åå•æ“ä½œ
async function isBlacklisted(env, odl_id) {
  const data = await env.USER_CONFIGS.get("blacklist:" + odl_id);
  return data === "true";
}

async function addToBlacklist(env, odl_id) {
  await env.USER_CONFIGS.put("blacklist:" + odl_id, "true");
}

async function removeFromBlacklist(env, odl_id) {
  await env.USER_CONFIGS.delete("blacklist:" + odl_id);
}

async function getBlacklist(env) {
  const userList = await getUserList(env);
  const blacklist = [];
  for (const odl_id of userList) {
    if (await isBlacklisted(env, odl_id)) {
      blacklist.push(odl_id);
    }
  }
  // ä¹Ÿæ£€æŸ¥ä¸åœ¨ç”¨æˆ·åˆ—è¡¨ä¸­çš„é»‘åå•
  const allKeys = await env.USER_CONFIGS.list({ prefix: "blacklist:" });
  for (const key of allKeys.keys) {
    const odl_id = parseInt(key.name.replace("blacklist:", ""));
    if (!blacklist.includes(odl_id)) {
      blacklist.push(odl_id);
    }
  }
  return blacklist;
}

// ==================== ä¼šè¯ç®¡ç† ====================

function setSession(odl_id, config) {
  userSessions.set(odl_id, {
    config: config,
    timestamp: Date.now()
  });
}

function getSession(odl_id) {
  const session = userSessions.get(odl_id);
  if (!session) return null;
  
  if (Date.now() - session.timestamp > SESSION_TIMEOUT) {
    userSessions.delete(odl_id);
    return null;
  }
  
  // åˆ·æ–°æ—¶é—´æˆ³
  session.timestamp = Date.now();
  return session.config;
}

function clearSession(odl_id) {
  userSessions.delete(odl_id);
}

// ==================== æƒé™æ£€æŸ¥ ====================

function isAdmin(odl_id, env) {
  if (!env.ADMIN_USER_IDS) return false;
  const admins = env.ADMIN_USER_IDS.split(",").map(s => s.trim());
  return admins.includes(String(odl_id));
}

async function getUserConfig(odl_id, env) {
  // ç®¡ç†å‘˜ä½¿ç”¨é»˜è®¤é…ç½®
  if (isAdmin(odl_id, env)) {
    return {
      ql_base_url: env.QL_BASE_URL,
      ql_client_id: env.QL_CLIENT_ID,
      ql_client_secret: env.QL_CLIENT_SECRET
    };
  }
  
  // æ™®é€šç”¨æˆ·ä»ä¼šè¯è·å–
  return getSession(odl_id);
}

// ==================== Telegram API ====================

async function tgApi(token, method, body = {}) {
  const resp = await fetch("https://api.telegram.org/bot" + token + "/" + method, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });
  return resp.json();
}

async function sendMsg(env, chatId, text, opts = {}) {
  return tgApi(env.TG_BOT_TOKEN, "sendMessage", {
    chat_id: chatId,
    text,
    parse_mode: "HTML",
    ...opts
  });
}

async function editMsg(env, chatId, msgId, text, opts = {}) {
  return tgApi(env.TG_BOT_TOKEN, "editMessageText", {
    chat_id: chatId,
    message_id: msgId,
    text,
    parse_mode: "HTML",
    ...opts
  });
}

async function answerCb(env, cbId, text) {
  return tgApi(env.TG_BOT_TOKEN, "answerCallbackQuery", {
    callback_query_id: cbId,
    text: text || ""
  });
}

// ==================== é’é¾™ API ====================

var qlTokenCache = new Map(); // userId -> { token, expiry }

async function getQlToken(env, userConfig, odl_id) {
  const cacheKey = odl_id;
  const cached = qlTokenCache.get(cacheKey);
  const now = Date.now();
  
  if (cached && cached.expiry > now + 300000) {
    return cached.token;
  }
  
  const url = userConfig.ql_base_url + "/open/auth/token?client_id=" + 
    userConfig.ql_client_id + "&client_secret=" + userConfig.ql_client_secret;
  
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 5000);
  
  try {
    const resp = await fetch(url, { signal: controller.signal });
    clearTimeout(timeoutId);
    const data = await resp.json();
    
    if (data.code === 200) {
      qlTokenCache.set(cacheKey, {
        token: data.data.token,
        expiry: now + data.data.expiration * 1000 - 120000
      });
      return data.data.token;
    }
    throw new Error(data.message || "è·å–Tokenå¤±è´¥");
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === "AbortError") {
      throw new Error("è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥é’é¾™åœ°å€");
    }
    throw error;
  }
}

async function qlApi(env, userConfig, odl_id, method, endpoint, body) {
  const token = await getQlToken(env, userConfig, odl_id);
  
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);
  
  try {
    const opts = {
      method,
      headers: {
        "Authorization": "Bearer " + token,
        "Content-Type": "application/json"
      },
      signal: controller.signal
    };
    
    if (body !== undefined && body !== null) {
      opts.body = JSON.stringify(body);
    }
    
    const resp = await fetch(userConfig.ql_base_url + endpoint, opts);
    clearTimeout(timeoutId);
    
    if (!resp.ok) {
      throw new Error("HTTP " + resp.status);
    }
    return resp.json();
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === "AbortError") {
      throw new Error("è¯·æ±‚è¶…æ—¶");
    }
    throw error;
  }
}

// ==================== API å·¥å…·å‡½æ•° ====================

function generateToken() {
  const arr = new Uint8Array(32);
  crypto.getRandomValues(arr);
  return ab2base64(arr).replace(/[+/=]/g, '').slice(0, 48);
}

function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}

function errorResponse(message, status = 400) {
  return jsonResponse({ error: true, message }, status);
}

async function validateApiToken(request, env) {
  const authHeader = request.headers.get("Authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return null;
  }
  
  const token = authHeader.slice(7);
  const tokenData = apiTokens.get(token);
  
  if (!tokenData) {
    return null;
  }
  
  if (Date.now() > tokenData.expiry) {
    apiTokens.delete(token);
    return null;
  }
  
  return tokenData;
}

// ==================== API è·¯ç”±å¤„ç† ====================

async function handleApiRequest(request, url, env) {
  // CORS é¢„æ£€
  if (request.method === "OPTIONS") {
    return new Response(null, {
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization"
      }
    });
  }

  const path = url.pathname.replace("/api", "");
  
  // è®¤è¯æ¥å£ - ä¸éœ€è¦ Token
  if (path === "/auth/token" && request.method === "POST") {
    return await handleAuthToken(request, env);
  }
  
  if (path === "/auth/admin" && request.method === "POST") {
    return await handleAdminAuth(request, env);
  }

  // å…¶ä»–æ¥å£éœ€è¦ Token è®¤è¯
  const tokenData = await validateApiToken(request, env);
  if (!tokenData) {
    return errorResponse("Unauthorized: Invalid or expired token", 401);
  }

  const { config, odl_id } = tokenData;

  // ç¯å¢ƒå˜é‡ API
  if (path === "/envs" && request.method === "GET") {
    return await apiGetEnvs(env, config, odl_id);
  }
  if (path === "/envs" && request.method === "POST") {
    return await apiCreateEnv(request, env, config, odl_id);
  }
  if (path.match(/^\/envs\/\d+$/) && request.method === "PUT") {
    const id = path.split("/")[2];
    return await apiUpdateEnv(request, env, config, odl_id, id);
  }
  if (path.match(/^\/envs\/\d+$/) && request.method === "DELETE") {
    const id = path.split("/")[2];
    return await apiDeleteEnv(env, config, odl_id, id);
  }
  if (path.match(/^\/envs\/\d+\/enable$/) && request.method === "PUT") {
    const id = path.split("/")[2];
    return await apiToggleEnv(env, config, odl_id, id, true);
  }
  if (path.match(/^\/envs\/\d+\/disable$/) && request.method === "PUT") {
    const id = path.split("/")[2];
    return await apiToggleEnv(env, config, odl_id, id, false);
  }

  // ä»»åŠ¡ API
  if (path === "/crons" && request.method === "GET") {
    return await apiGetCrons(env, config, odl_id);
  }
  if (path === "/crons" && request.method === "POST") {
    return await apiCreateCron(request, env, config, odl_id);
  }
  if (path.match(/^\/crons\/\d+$/) && request.method === "PUT") {
    const id = path.split("/")[2];
    return await apiUpdateCron(request, env, config, odl_id, id);
  }
  if (path.match(/^\/crons\/\d+$/) && request.method === "DELETE") {
    const id = path.split("/")[2];
    return await apiDeleteCron(env, config, odl_id, id);
  }
  if (path.match(/^\/crons\/\d+\/run$/) && request.method === "PUT") {
    const id = path.split("/")[2];
    return await apiRunCron(env, config, odl_id, id);
  }
  if (path.match(/^\/crons\/\d+\/stop$/) && request.method === "PUT") {
    const id = path.split("/")[2];
    return await apiStopCron(env, config, odl_id, id);
  }
  if (path.match(/^\/crons\/\d+\/log$/) && request.method === "GET") {
    const id = path.split("/")[2];
    return await apiGetCronLog(env, config, odl_id, id);
  }

  // è®¢é˜… API
  if (path === "/subscriptions" && request.method === "GET") {
    return await apiGetSubs(env, config, odl_id);
  }
  if (path === "/subscriptions" && request.method === "POST") {
    return await apiCreateSub(request, env, config, odl_id);
  }
  if (path.match(/^\/subscriptions\/\d+$/) && request.method === "DELETE") {
    const id = path.split("/")[2];
    return await apiDeleteSub(env, config, odl_id, id);
  }
  if (path.match(/^\/subscriptions\/\d+\/run$/) && request.method === "PUT") {
    const id = path.split("/")[2];
    return await apiRunSub(env, config, odl_id, id);
  }

  // è„šæœ¬ API
  if (path === "/scripts" && request.method === "GET") {
    return await apiGetScripts(env, config, odl_id);
  }
  if (path === "/scripts" && request.method === "POST") {
    return await apiUploadScript(request, env, config, odl_id);
  }
  if (path.match(/^\/scripts\/[^/]+$/) && request.method === "GET") {
    const filename = decodeURIComponent(path.split("/")[2]);
    const scriptPath = url.searchParams.get("path") || "";
    return await apiGetScriptContent(env, config, odl_id, filename, scriptPath);
  }
  if (path.match(/^\/scripts\/[^/]+$/) && request.method === "DELETE") {
    const filename = decodeURIComponent(path.split("/")[2]);
    const scriptPath = url.searchParams.get("path") || "";
    return await apiDeleteScript(env, config, odl_id, filename, scriptPath);
  }

  // ä¾èµ– API
  if (path === "/dependencies" && request.method === "GET") {
    const type = url.searchParams.get("type") || "nodejs";
    return await apiGetDeps(env, config, odl_id, type);
  }
  if (path === "/dependencies" && request.method === "POST") {
    return await apiCreateDep(request, env, config, odl_id);
  }
  if (path.match(/^\/dependencies\/\d+$/) && request.method === "DELETE") {
    const id = path.split("/")[2];
    return await apiDeleteDep(env, config, odl_id, id);
  }

  return errorResponse("Not Found", 404);
}

// ==================== API è®¤è¯å¤„ç† ====================

async function handleAuthToken(request, env) {
  try {
    const body = await request.json();
    const { user_id, pin } = body;
    
    if (!user_id || !pin) {
      return errorResponse("Missing user_id or pin");
    }
    
    // æ£€æŸ¥é»‘åå•
    if (await isBlacklisted(env, user_id)) {
      return errorResponse("User is blacklisted", 403);
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç®¡ç†å‘˜
    if (isAdmin(user_id, env)) {
      const config = {
        ql_base_url: env.QL_BASE_URL,
        ql_client_id: env.QL_CLIENT_ID,
        ql_client_secret: env.QL_CLIENT_SECRET
      };
      
      const token = generateToken();
      apiTokens.set(token, {
        odl_id: user_id,
        config,
        expiry: Date.now() + API_TOKEN_EXPIRY
      });
      
      return jsonResponse({
        token,
        expires_in: API_TOKEN_EXPIRY / 1000,
        user_type: "admin"
      });
    }
    
    // æ™®é€šç”¨æˆ· - éªŒè¯ PIN å¹¶è§£å¯†é…ç½®
    const encryptedConfig = await getUserEncryptedConfig(env, user_id);
    if (!encryptedConfig) {
      return errorResponse("User not registered. Please setup via Telegram Bot first.", 404);
    }
    
    const config = await decryptConfig(encryptedConfig, pin, user_id);
    if (!config) {
      return errorResponse("Invalid PIN", 401);
    }
    
    const token = generateToken();
    apiTokens.set(token, {
      odl_id: user_id,
      config,
      expiry: Date.now() + API_TOKEN_EXPIRY
    });
    
    // æ›´æ–°æœ€åæ´»è·ƒæ—¶é—´
    const meta = await getUserMeta(env, user_id);
    if (meta) {
      meta.last_active = Date.now();
      await env.USER_CONFIGS.put("meta:" + user_id, JSON.stringify(meta));
    }
    
    return jsonResponse({
      token,
      expires_in: API_TOKEN_EXPIRY / 1000,
      user_type: "user"
    });
  } catch (e) {
    return errorResponse("Auth failed: " + e.message, 500);
  }
}

async function handleAdminAuth(request, env) {
  try {
    const body = await request.json();
    const { secret } = body;
    
    if (!secret || secret !== env.API_SECRET) {
      return errorResponse("Invalid API secret", 401);
    }
    
    const config = {
      ql_base_url: env.QL_BASE_URL,
      ql_client_id: env.QL_CLIENT_ID,
      ql_client_secret: env.QL_CLIENT_SECRET
    };
    
    const token = generateToken();
    apiTokens.set(token, {
      odl_id: 0, // ç®¡ç†å‘˜ API
      config,
      expiry: Date.now() + API_TOKEN_EXPIRY
    });
    
    return jsonResponse({
      token,
      expires_in: API_TOKEN_EXPIRY / 1000,
      user_type: "api_admin"
    });
  } catch (e) {
    return errorResponse("Auth failed: " + e.message, 500);
  }
}

// ==================== API ç¯å¢ƒå˜é‡å¤„ç† ====================

async function apiGetEnvs(env, config, odl_id) {
  try {
    const result = await qlApi(env, config, odl_id, "GET", "/open/envs", null);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiCreateEnv(request, env, config, odl_id) {
  try {
    const body = await request.json();
    const { name, value, remarks } = body;
    
    if (!name || !value) {
      return errorResponse("Missing name or value");
    }
    
    const envData = [{ name, value }];
    if (remarks) envData[0].remarks = remarks;
    
    const result = await qlApi(env, config, odl_id, "POST", "/open/envs", envData);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiUpdateEnv(request, env, config, odl_id, id) {
  try {
    const body = await request.json();
    const { name, value, remarks } = body;
    
    const updateData = { id: parseInt(id) };
    if (name) updateData.name = name;
    if (value) updateData.value = value;
    if (remarks !== undefined) updateData.remarks = remarks;
    
    const result = await qlApi(env, config, odl_id, "PUT", "/open/envs", updateData);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiDeleteEnv(env, config, odl_id, id) {
  try {
    const result = await qlApi(env, config, odl_id, "DELETE", "/open/envs", [parseInt(id)]);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiToggleEnv(env, config, odl_id, id, enable) {
  try {
    const endpoint = enable ? "/open/envs/enable" : "/open/envs/disable";
    const result = await qlApi(env, config, odl_id, "PUT", endpoint, [parseInt(id)]);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

// ==================== API ä»»åŠ¡å¤„ç† ====================

async function apiGetCrons(env, config, odl_id) {
  try {
    const result = await qlApi(env, config, odl_id, "GET", "/open/crons", null);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiCreateCron(request, env, config, odl_id) {
  try {
    const body = await request.json();
    const { name, command, schedule } = body;
    
    if (!name || !command || !schedule) {
      return errorResponse("Missing name, command or schedule");
    }
    
    const result = await qlApi(env, config, odl_id, "POST", "/open/crons", { name, command, schedule });
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiUpdateCron(request, env, config, odl_id, id) {
  try {
    const body = await request.json();
    const updateData = { id: parseInt(id), ...body };
    
    const result = await qlApi(env, config, odl_id, "PUT", "/open/crons", updateData);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiDeleteCron(env, config, odl_id, id) {
  try {
    const result = await qlApi(env, config, odl_id, "DELETE", "/open/crons", [parseInt(id)]);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiRunCron(env, config, odl_id, id) {
  try {
    const result = await qlApi(env, config, odl_id, "PUT", "/open/crons/run", [parseInt(id)]);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiStopCron(env, config, odl_id, id) {
  try {
    const result = await qlApi(env, config, odl_id, "PUT", "/open/crons/stop", [parseInt(id)]);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiGetCronLog(env, config, odl_id, id) {
  try {
    const result = await qlApi(env, config, odl_id, "GET", "/open/crons/" + id + "/log", null);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

// ==================== API è®¢é˜…å¤„ç† ====================

async function apiGetSubs(env, config, odl_id) {
  try {
    const result = await qlApi(env, config, odl_id, "GET", "/open/subscriptions", null);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiCreateSub(request, env, config, odl_id) {
  try {
    const body = await request.json();
    const { name, url, schedule, branch } = body;
    
    if (!name || !url) {
      return errorResponse("Missing name or url");
    }
    
    const subData = {
      name,
      url,
      schedule: schedule || "0 0 * * *",
      type: "public-repo"
    };
    if (branch) subData.branch = branch;
    
    const result = await qlApi(env, config, odl_id, "POST", "/open/subscriptions", subData);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiDeleteSub(env, config, odl_id, id) {
  try {
    const result = await qlApi(env, config, odl_id, "DELETE", "/open/subscriptions", [parseInt(id)]);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiRunSub(env, config, odl_id, id) {
  try {
    const result = await qlApi(env, config, odl_id, "PUT", "/open/subscriptions/run", [parseInt(id)]);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

// ==================== API è„šæœ¬å¤„ç† ====================

async function apiGetScripts(env, config, odl_id) {
  try {
    const result = await qlApi(env, config, odl_id, "GET", "/open/scripts", null);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiGetScriptContent(env, config, odl_id, filename, path) {
  try {
    const endpoint = "/open/scripts/" + encodeURIComponent(filename) + "?path=" + encodeURIComponent(path);
    const result = await qlApi(env, config, odl_id, "GET", endpoint, null);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiUploadScript(request, env, config, odl_id) {
  try {
    const body = await request.json();
    const { filename, content, path } = body;
    
    if (!filename || content === undefined) {
      return errorResponse("Missing filename or content");
    }
    
    const result = await qlApi(env, config, odl_id, "POST", "/open/scripts", {
      filename,
      content,
      path: path || ""
    });
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiDeleteScript(env, config, odl_id, filename, path) {
  try {
    const result = await qlApi(env, config, odl_id, "DELETE", "/open/scripts", {
      filename,
      path: path || ""
    });
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

// ==================== API ä¾èµ–å¤„ç† ====================

async function apiGetDeps(env, config, odl_id, type) {
  try {
    const result = await qlApi(env, config, odl_id, "GET", "/open/dependencies?type=" + type, null);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiCreateDep(request, env, config, odl_id) {
  try {
    const body = await request.json();
    const { name, type } = body;
    
    if (!name) {
      return errorResponse("Missing dependency name");
    }
    
    const typeMap = { "python3": 0, "nodejs": 1, "linux": 2 };
    const typeNum = typeMap[type] !== undefined ? typeMap[type] : 1;
    
    const names = Array.isArray(name) ? name : [name];
    const depData = names.map(n => ({ name: n, type: typeNum }));
    
    const result = await qlApi(env, config, odl_id, "POST", "/open/dependencies", depData);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

async function apiDeleteDep(env, config, odl_id, id) {
  try {
    const result = await qlApi(env, config, odl_id, "DELETE", "/open/dependencies", [parseInt(id)]);
    return jsonResponse(result);
  } catch (e) {
    return errorResponse(e.message, 500);
  }
}

// ==================== ä¸»å¤„ç†é€»è¾‘ ====================

var src_default = {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // API è·¯ç”±
    if (url.pathname.startsWith("/api")) {
      return await handleApiRequest(request, url, env);
    }
    
    if (url.pathname === "/set-webhook") {
      if (url.searchParams.get("secret") !== env.WEBHOOK_SECRET) {
        return new Response("Unauthorized", { status: 401 });
      }
      const webhookUrl = url.origin + "/webhook";
      const resp = await tgApi(env.TG_BOT_TOKEN, "setWebhook", {
        url: webhookUrl,
        allowed_updates: ["message", "callback_query"]
      });
      return new Response(JSON.stringify({ webhookUrl, result: resp }, null, 2));
    }
    
    if (url.pathname === "/health") {
      return new Response("OK - v5.0 Multi-User API");
    }
    
    if (url.pathname === "/webhook" && request.method === "POST") {
      try {
        const update = await request.json();
        ctx.waitUntil(processUpdate(update, env));
        return new Response("OK");
      } catch (e) {
        console.error("Webhook error:", e);
        return new Response("Error", { status: 500 });
      }
    }
    
    return new Response("Qinglong Bot v5.0 Multi-User API");
  }
};

async function processUpdate(update, env) {
  try {
    let odl_id, chatId, username, firstName;
    
    if (update.callback_query) {
      odl_id = update.callback_query.from.id;
      chatId = update.callback_query.message.chat.id;
      username = update.callback_query.from.username;
      firstName = update.callback_query.from.first_name;
    } else if (update.message) {
      odl_id = update.message.from.id;
      chatId = update.message.chat.id;
      username = update.message.from.username;
      firstName = update.message.from.first_name;
    } else {
      return;
    }
    
    // æ£€æŸ¥é»‘åå•
    if (await isBlacklisted(env, odl_id)) {
      await sendMsg(env, chatId, "â›” æ‚¨å·²è¢«ç¦æ­¢ä½¿ç”¨æ­¤ Bot");
      return;
    }
    
    // å¤„ç†å›è°ƒ
    if (update.callback_query) {
      await handleCallback(update.callback_query, env);
      return;
    }
    
    // å¤„ç†æ¶ˆæ¯
    if (update.message) {
      await handleMessage(update.message, env);
      return;
    }
  } catch (error) {
    console.error("Process error:", error);
    const chatId = update.message?.chat?.id || update.callback_query?.message?.chat?.id;
    if (chatId) {
      await sendMsg(env, chatId, "âŒ é”™è¯¯: " + error.message);
    }
  }
}

async function handleMessage(msg, env) {
  const chatId = msg.chat.id;
  const odl_id = msg.from.id;
  const text = (msg.text || "").trim();
  const username = msg.from.username;
  const firstName = msg.from.first_name;
  
  // æ£€æŸ¥æ˜¯å¦åœ¨è¾“å…¥çŠ¶æ€
  const state = userStates.get(odl_id);
  if (state) {
    await handleStateInput(msg, state, env);
    return;
  }
  
  // å¤„ç†å‘½ä»¤
  if (text.startsWith("/")) {
    const cmd = text.split(" ")[0].split("@")[0];
    
    // ä¸éœ€è¦éªŒè¯çš„å‘½ä»¤
    if (cmd === "/start") {
      return await cmdStart(chatId, odl_id, username, firstName, env);
    }
    if (cmd === "/help") {
      return await cmdHelp(chatId, odl_id, env);
    }
    if (cmd === "/cancel") {
      userStates.delete(odl_id);
      return await sendMsg(env, chatId, "âŒ å·²å–æ¶ˆ");
    }
    
    // ç®¡ç†å‘˜å‘½ä»¤
    if (cmd === "/users" && isAdmin(odl_id, env)) {
      return await cmdUsers(chatId, 0, env, null);
    }
    
    // æˆ‘çš„é…ç½®
    if (cmd === "/myconfig") {
      return await cmdMyConfig(chatId, odl_id, env);
    }
    
    // éœ€è¦éªŒè¯çš„å‘½ä»¤
    const config = await getUserConfig(odl_id, env);
    if (!config) {
      // æ£€æŸ¥æ˜¯å¦æœ‰å·²ä¿å­˜çš„é…ç½®éœ€è¦è§£é”
      const hasConfig = await getUserEncryptedConfig(env, odl_id);
      if (hasConfig) {
        return await promptUnlock(chatId, odl_id, env);
      } else {
        return await promptSetup(chatId, odl_id, env);
      }
    }
    
    // å·²éªŒè¯ï¼Œæ‰§è¡Œå‘½ä»¤
    switch (cmd) {
      case "/tasks":
        return await cmdTasks(chatId, odl_id, 0, env, config, null);
      case "/envs":
        return await cmdEnvs(chatId, odl_id, 0, env, config, null);
      case "/subs":
        return await cmdSubs(chatId, odl_id, 0, env, config, null);
      case "/deps":
        return await cmdDeps(chatId, odl_id, env, config, null);
      case "/scripts":
        return await cmdScripts(chatId, odl_id, "", 0, env, config, null);
    }
  }
  
  // å¿«æ·èœå•æ–‡æœ¬
  if (text.includes("ä»»åŠ¡ç®¡ç†") || text.includes("ç¯å¢ƒå˜é‡") || 
      text.includes("è®¢é˜…ç®¡ç†") || text.includes("ä¾èµ–ç®¡ç†") || 
      text.includes("è„šæœ¬ç®¡ç†")) {
    const config = await getUserConfig(odl_id, env);
    if (!config) {
      const hasConfig = await getUserEncryptedConfig(env, odl_id);
      if (hasConfig) {
        return await promptUnlock(chatId, odl_id, env);
      } else {
        return await promptSetup(chatId, odl_id, env);
      }
    }
    
    if (text.includes("ä»»åŠ¡ç®¡ç†")) return await cmdTasks(chatId, odl_id, 0, env, config, null);
    if (text.includes("ç¯å¢ƒå˜é‡")) return await cmdEnvs(chatId, odl_id, 0, env, config, null);
    if (text.includes("è®¢é˜…ç®¡ç†")) return await cmdSubs(chatId, odl_id, 0, env, config, null);
    if (text.includes("ä¾èµ–ç®¡ç†")) return await cmdDeps(chatId, odl_id, env, config, null);
    if (text.includes("è„šæœ¬ç®¡ç†")) return await cmdScripts(chatId, odl_id, "", 0, env, config, null);
  }
}

// ==================== ç”¨æˆ·è®¾ç½®æµç¨‹ ====================

async function promptSetup(chatId, odl_id, env) {
  const kb = {
    inline_keyboard: [
      [{ text: "âœ… æ·»åŠ æˆ‘çš„é’é¾™é¢æ¿", callback_data: "setup_start" }],
      [{ text: "âŒ å–æ¶ˆ", callback_data: "setup_cancel" }]
    ]
  };
  
  await sendMsg(env, chatId, 
    "ğŸ‘‹ <b>æ¬¢è¿ä½¿ç”¨é’é¾™é¢æ¿ Bot</b>\n\n" +
    "æ‚¨è¿˜æ²¡æœ‰é…ç½®é’é¾™é¢æ¿ã€‚\n\n" +
    "ğŸ” <b>å®‰å…¨è¯´æ˜ï¼š</b>\n" +
    "â€¢ æ‚¨çš„å‡­è¯å°†ä½¿ç”¨ PIN åŠ å¯†å­˜å‚¨\n" +
    "â€¢ åªæœ‰æ‚¨çŸ¥é“ PINï¼Œä»»ä½•äººæ— æ³•è§£å¯†\n" +
    "â€¢ æ‚¨å¯ä»¥éšæ—¶åˆ é™¤è‡ªå·±çš„é…ç½®\n\n" +
    "æ˜¯å¦è¦æ·»åŠ æ‚¨çš„é’é¾™é¢æ¿ï¼Ÿ",
    { reply_markup: kb }
  );
}

async function promptUnlock(chatId, odl_id, env) {
  userStates.set(odl_id, { 
    action: "unlock", 
    chatId,
    attempts: 0 
  });
  
  await sendMsg(env, chatId,
    "ğŸ” <b>è¯·è¾“å…¥ PIN ç è§£é”</b>\n\n" +
    "è¯·è¾“å…¥æ‚¨çš„ 6 ä½æ•°å­— PIN ç æ¥è§£é”é’é¾™é¢æ¿ã€‚\n\n" +
    "ğŸ’¡ PIN é”™è¯¯ 5 æ¬¡å°†é”å®š 10 åˆ†é’Ÿ\n\n" +
    "/cancel å–æ¶ˆ",
    { reply_markup: { inline_keyboard: [[{ text: "ğŸ—‘ï¸ å¿˜è®°PIN/åˆ é™¤é…ç½®", callback_data: "forget_pin" }]] } }
  );
}

async function startSetup(chatId, odl_id, msgId, env) {
  userStates.set(odl_id, {
    action: "setup_url",
    chatId,
    msgId
  });
  
  await editMsg(env, chatId, msgId,
    "ğŸ“ <b>æ­¥éª¤ 1/4ï¼šé’é¾™é¢æ¿åœ°å€</b>\n\n" +
    "è¯·è¾“å…¥æ‚¨çš„é’é¾™é¢æ¿åœ°å€\n" +
    "ä¾‹å¦‚ï¼š<code>http://192.168.1.100:5700</code>\n\n" +
    "âš ï¸ è¯·ç¡®ä¿åœ°å€å¯ä»¥ä»å…¬ç½‘è®¿é—®\n\n" +
    "/cancel å–æ¶ˆ"
  );
}

// ==================== å‘½ä»¤å¤„ç† ====================

async function cmdStart(chatId, odl_id, username, firstName, env) {
  const keyboard = {
    keyboard: [
      [{ text: "ğŸ“‹ ä»»åŠ¡ç®¡ç†" }, { text: "ğŸ”‘ ç¯å¢ƒå˜é‡" }],
      [{ text: "ğŸ“¦ è®¢é˜…ç®¡ç†" }, { text: "ğŸ“š ä¾èµ–ç®¡ç†" }],
      [{ text: "ğŸ“ è„šæœ¬ç®¡ç†" }, { text: "â“ å¸®åŠ©" }]
    ],
    resize_keyboard: true,
    persistent: true
  };
  
  if (isAdmin(odl_id, env)) {
    await sendMsg(env, chatId,
      "ğŸ‰ <b>é’é¾™é¢æ¿ Bot v4.0</b>\n\n" +
      "ğŸ‘‘ <b>ç®¡ç†å‘˜æ¨¡å¼</b>\n\n" +
      "â€¢ ä½¿ç”¨é»˜è®¤é’é¾™é…ç½®\n" +
      "â€¢ /users - ç”¨æˆ·ç®¡ç†\n\n" +
      "è¯·é€‰æ‹©æ“ä½œï¼š",
      { reply_markup: keyboard }
    );
  } else {
    const hasConfig = await getUserEncryptedConfig(env, odl_id);
    const config = getSession(odl_id);
    
    if (config) {
      await sendMsg(env, chatId,
        "ğŸ‰ <b>é’é¾™é¢æ¿ Bot v4.0</b>\n\n" +
        "âœ… å·²è§£é”ï¼Œè¯·é€‰æ‹©æ“ä½œï¼š",
        { reply_markup: keyboard }
      );
    } else if (hasConfig) {
      await promptUnlock(chatId, odl_id, env);
    } else {
      await promptSetup(chatId, odl_id, env);
    }
  }
}

async function cmdHelp(chatId, odl_id, env) {
  let text = "ğŸ‰ <b>é’é¾™é¢æ¿ Bot å¸®åŠ©</b>\n\n";
  text += "/tasks - ğŸ“‹ ä»»åŠ¡ç®¡ç†\n";
  text += "/envs - ğŸ”‘ ç¯å¢ƒå˜é‡\n";
  text += "/subs - ğŸ“¦ è®¢é˜…ç®¡ç†\n";
  text += "/deps - ğŸ“š ä¾èµ–ç®¡ç†\n";
  text += "/scripts - ğŸ“ è„šæœ¬ç®¡ç†\n";
  text += "/myconfig - âš™ï¸ æˆ‘çš„é…ç½®\n";
  
  if (isAdmin(odl_id, env)) {
    text += "\n<b>ğŸ‘‘ ç®¡ç†å‘˜å‘½ä»¤ï¼š</b>\n";
    text += "/users - ç”¨æˆ·ç®¡ç†\n";
  }
  
  text += "\nğŸ” æ‚¨çš„å‡­è¯å·²åŠ å¯†å­˜å‚¨ï¼Œåªæœ‰æ‚¨èƒ½è§£é”";
  
  await sendMsg(env, chatId, text);
}

async function cmdMyConfig(chatId, odl_id, env) {
  if (isAdmin(odl_id, env)) {
    return await sendMsg(env, chatId,
      "ğŸ‘‘ <b>ç®¡ç†å‘˜é…ç½®</b>\n\n" +
      "æ‚¨ä½¿ç”¨çš„æ˜¯é»˜è®¤é’é¾™é…ç½®ï¼ˆç¯å¢ƒå˜é‡ï¼‰\n" +
      "URL: <code>" + (env.QL_BASE_URL || "æœªè®¾ç½®") + "</code>"
    );
  }
  
  const hasConfig = await getUserEncryptedConfig(env, odl_id);
  const meta = await getUserMeta(env, odl_id);
  
  if (!hasConfig) {
    return await promptSetup(chatId, odl_id, env);
  }
  
  const isUnlocked = !!getSession(odl_id);
  
  let text = "âš™ï¸ <b>æˆ‘çš„é…ç½®</b>\n\n";
  text += "çŠ¶æ€: " + (isUnlocked ? "ğŸ”“ å·²è§£é”" : "ğŸ”’ å·²é”å®š") + "\n";
  if (meta) {
    text += "åˆ›å»ºæ—¶é—´: " + new Date(meta.created_at).toLocaleString("zh-CN") + "\n";
    text += "æœ€åæ´»è·ƒ: " + new Date(meta.last_active).toLocaleString("zh-CN") + "\n";
  }
  
  const kb = [];
  if (isUnlocked) {
    kb.push([{ text: "ğŸ”’ é”å®šä¼šè¯", callback_data: "lock_session" }]);
  }
  kb.push([{ text: "ğŸ”„ ä¿®æ”¹ PIN", callback_data: "change_pin" }]);
  kb.push([{ text: "ğŸ—‘ï¸ åˆ é™¤é…ç½®", callback_data: "delete_config" }]);
  
  await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: kb } });
}

// ==================== ç®¡ç†å‘˜ç”¨æˆ·ç®¡ç† ====================

async function cmdUsers(chatId, page, env, msgId) {
  const userList = await getUserList(env);
  const blacklist = await getBlacklist(env);
  
  if (userList.length === 0 && blacklist.length === 0) {
    const text = "ğŸ‘¥ <b>ç”¨æˆ·ç®¡ç†</b>\n\næš‚æ— ç”¨æˆ·";
    if (msgId) return await editMsg(env, chatId, msgId, text);
    return await sendMsg(env, chatId, text);
  }
  
  const pageSize = 8;
  const allUsers = [...new Set([...userList, ...blacklist])];
  const totalPages = Math.ceil(allUsers.length / pageSize);
  const p = Math.min(Math.max(0, page), totalPages - 1);
  const items = allUsers.slice(p * pageSize, (p + 1) * pageSize);
  
  const keyboard = [];
  
  for (const odl_id of items) {
    const meta = await getUserMeta(env, odl_id);
    const isBanned = blacklist.includes(odl_id);
    const icon = isBanned ? "ğŸš«" : "ğŸ‘¤";
    const name = meta?.username || meta?.first_name || String(odl_id);
    keyboard.push([{ 
      text: icon + " " + name.slice(0, 20), 
      callback_data: "user_" + odl_id 
    }]);
  }
  
  // åˆ†é¡µ
  const nav = [];
  if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "users_" + (p - 1) });
  nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
  if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "users_" + (p + 1) });
  if (nav.length > 1) keyboard.push(nav);
  
  keyboard.push([{ text: "ğŸ”„ åˆ·æ–°", callback_data: "users_refresh" }]);
  
  const text = "ğŸ‘¥ <b>ç”¨æˆ·ç®¡ç†</b>\n\n" +
    "å…± " + userList.length + " ä¸ªç”¨æˆ· | ğŸš« " + blacklist.length + " ä¸ªé»‘åå•";
  
  if (msgId) {
    return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
  }
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: keyboard } });
}

async function showUser(chatId, msgId, targetUserId, env) {
  const meta = await getUserMeta(env, targetUserId);
  const hasConfig = await getUserEncryptedConfig(env, targetUserId);
  const isBanned = await isBlacklisted(env, targetUserId);
  
  let text = "ğŸ‘¤ <b>ç”¨æˆ·è¯¦æƒ…</b>\n\n";
  text += "ID: <code>" + targetUserId + "</code>\n";
  
  if (meta) {
    if (meta.username) text += "ç”¨æˆ·å: @" + meta.username + "\n";
    if (meta.first_name) text += "åç§°: " + meta.first_name + "\n";
    text += "æ³¨å†Œæ—¶é—´: " + new Date(meta.created_at).toLocaleString("zh-CN") + "\n";
    text += "æœ€åæ´»è·ƒ: " + new Date(meta.last_active).toLocaleString("zh-CN") + "\n";
  }
  
  text += "é…ç½®çŠ¶æ€: " + (hasConfig ? "âœ… å·²é…ç½®" : "âŒ æœªé…ç½®") + "\n";
  text += "è´¦å·çŠ¶æ€: " + (isBanned ? "ğŸš« å·²æ‹‰é»‘" : "âœ… æ­£å¸¸") + "\n";
  
  const kb = [];
  if (isBanned) {
    kb.push([{ text: "âœ… è§£é™¤æ‹‰é»‘", callback_data: "unban_" + targetUserId }]);
  } else {
    kb.push([{ text: "ğŸš« æ‹‰é»‘ç”¨æˆ·", callback_data: "ban_" + targetUserId }]);
  }
  if (hasConfig) {
    kb.push([{ text: "ğŸ—‘ï¸ åˆ é™¤é…ç½®", callback_data: "admindel_" + targetUserId }]);
  }
  kb.push([{ text: "â¬…ï¸ è¿”å›åˆ—è¡¨", callback_data: "users_0" }]);
  
  await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
}

// ==================== åŠŸèƒ½å‘½ä»¤ï¼ˆéœ€è¦é…ç½®ï¼‰====================

function toArray(result) {
  if (!result || result.code !== 200) return [];
  const d = result.data;
  if (Array.isArray(d)) return d;
  if (d && Array.isArray(d.data)) return d.data;
  return [];
}

async function cmdTasks(chatId, odl_id, page, env, config, msgId) {
  const result = await qlApi(env, config, odl_id, "GET", "/open/crons", null);
  const crons = toArray(result);
  
  if (crons.length === 0) {
    const text = "ğŸ“‹ <b>ä»»åŠ¡ç®¡ç†</b>\n\næš‚æ— ä»»åŠ¡";
    const kb = { inline_keyboard: [[{ text: "â• æ–°å»ºä»»åŠ¡", callback_data: "task_new" }]] };
    if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: kb });
    return await sendMsg(env, chatId, text, { reply_markup: kb });
  }
  
  const pageSize = 8;
  const totalPages = Math.ceil(crons.length / pageSize);
  const p = Math.min(Math.max(0, page), totalPages - 1);
  const items = crons.slice(p * pageSize, (p + 1) * pageSize);
  
  const keyboard = [];
  for (const c of items) {
    const icon = c.isDisabled ? "ğŸ”•" : c.isRunning ? "ğŸƒ" : "âœ…";
    const name = (c.name || "æœªå‘½å").slice(0, 22);
    keyboard.push([{ text: icon + " " + name, callback_data: "cron_" + c.id }]);
  }
  
  const nav = [];
  if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "tasks_" + (p - 1) });
  nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
  if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "tasks_" + (p + 1) });
  keyboard.push(nav);
  keyboard.push([
    { text: "ğŸ”„ åˆ·æ–°", callback_data: "tasks_refresh_" + p },
    { text: "â• æ–°å»º", callback_data: "task_new" }
  ]);
  
  const running = crons.filter(c => c.isRunning).length;
  const enabled = crons.filter(c => !c.isDisabled).length;
  const text = "ğŸ“‹ <b>ä»»åŠ¡ç®¡ç†</b>\n\nå…± " + crons.length + " ä¸ª | âœ…" + enabled + " ğŸƒ" + running;
  
  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: keyboard } });
}

async function cmdEnvs(chatId, odl_id, page, env, config, msgId) {
  const result = await qlApi(env, config, odl_id, "GET", "/open/envs", null);
  const envs = toArray(result);
  
  if (envs.length === 0) {
    const text = "ğŸ”‘ <b>ç¯å¢ƒå˜é‡</b>\n\næš‚æ— å˜é‡";
    const kb = { inline_keyboard: [[{ text: "â• æ·»åŠ å˜é‡", callback_data: "env_add" }]] };
    if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: kb });
    return await sendMsg(env, chatId, text, { reply_markup: kb });
  }
  
  const pageSize = 8;
  const totalPages = Math.ceil(envs.length / pageSize);
  const p = Math.min(Math.max(0, page), totalPages - 1);
  const items = envs.slice(p * pageSize, (p + 1) * pageSize);
  
  const keyboard = [];
  for (const e of items) {
    const icon = e.status === 0 ? "âœ…" : "ğŸ”•";
    const name = (e.name || "æœªå‘½å").slice(0, 22);
    keyboard.push([{ text: icon + " " + name, callback_data: "env_" + e.id }]);
  }
  
  const nav = [];
  if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "envs_" + (p - 1) });
  nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
  if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "envs_" + (p + 1) });
  keyboard.push(nav);
  keyboard.push([
    { text: "â• æ·»åŠ ", callback_data: "env_add" },
    { text: "ğŸ”„ åˆ·æ–°", callback_data: "envs_refresh_" + p }
  ]);
  
  const text = "ğŸ”‘ <b>ç¯å¢ƒå˜é‡</b>\n\nå…± " + envs.length + " ä¸ª";
  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: keyboard } });
}

async function cmdSubs(chatId, odl_id, page, env, config, msgId) {
  const result = await qlApi(env, config, odl_id, "GET", "/open/subscriptions", null);
  const subs = toArray(result);
  
  if (subs.length === 0) {
    const text = "ğŸ“¦ <b>è®¢é˜…ç®¡ç†</b>\n\næš‚æ— è®¢é˜…";
    const kb = { inline_keyboard: [[{ text: "â• æ·»åŠ è®¢é˜…", callback_data: "sub_add" }]] };
    if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: kb });
    return await sendMsg(env, chatId, text, { reply_markup: kb });
  }
  
  const pageSize = 8;
  const totalPages = Math.ceil(subs.length / pageSize);
  const p = Math.min(Math.max(0, page), totalPages - 1);
  const items = subs.slice(p * pageSize, (p + 1) * pageSize);
  
  const keyboard = [];
  for (const s of items) {
    const icon = s.is_disabled ? "ğŸ”•" : "âœ…";
    const name = (s.name || "æœªå‘½å").slice(0, 22);
    keyboard.push([{ text: icon + " " + name, callback_data: "sub_" + s.id }]);
  }
  
  const nav = [];
  if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "subs_" + (p - 1) });
  nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
  if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "subs_" + (p + 1) });
  keyboard.push(nav);
  keyboard.push([
    { text: "â• æ·»åŠ ", callback_data: "sub_add" },
    { text: "ğŸ”„ åˆ·æ–°", callback_data: "subs_refresh_" + p }
  ]);
  
  const text = "ğŸ“¦ <b>è®¢é˜…ç®¡ç†</b>\n\nå…± " + subs.length + " ä¸ª";
  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: keyboard } });
}

async function cmdDeps(chatId, odl_id, env, config, msgId) {
  const results = await Promise.allSettled([
    qlApi(env, config, odl_id, "GET", "/open/dependencies?type=python3", null),
    qlApi(env, config, odl_id, "GET", "/open/dependencies?type=nodejs", null),
    qlApi(env, config, odl_id, "GET", "/open/dependencies?type=linux", null)
  ]);
  
  const pythonDeps = results[0].status === "fulfilled" ? toArray(results[0].value) : [];
  const nodeDeps = results[1].status === "fulfilled" ? toArray(results[1].value) : [];
  const linuxDeps = results[2].status === "fulfilled" ? toArray(results[2].value) : [];
  const total = pythonDeps.length + nodeDeps.length + linuxDeps.length;
  
  const kb = [
    [{ text: "ğŸ Python (" + pythonDeps.length + ")", callback_data: "dep_list_python3" }],
    [{ text: "ğŸ“¦ Node.js (" + nodeDeps.length + ")", callback_data: "dep_list_nodejs" }],
    [{ text: "ğŸ§ Linux (" + linuxDeps.length + ")", callback_data: "dep_list_linux" }],
    [{ text: "ğŸ”„ åˆ·æ–°", callback_data: "deps_refresh" }]
  ];
  
  const text = "ğŸ“š <b>ä¾èµ–ç®¡ç†</b>\n\nå…± " + total + " ä¸ªä¾èµ–";
  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: kb } });
}

async function cmdScripts(chatId, odl_id, folder, page, env, config, msgId) {
  const result = await qlApi(env, config, odl_id, "GET", "/open/scripts", null);
  
  if (result.code !== 200) {
    const text = "âŒ è·å–å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯");
    if (msgId) return await editMsg(env, chatId, msgId, text);
    return await sendMsg(env, chatId, text);
  }
  
  const data = result.data || [];
  let folders = [];
  let files = [];
  
  if (!folder) {
    for (const item of data) {
      if (item.children && item.children.length > 0) {
        folders.push(item.title);
      } else if (item.title) {
        files.push(item.title);
      }
    }
  } else {
    const findNode = (items, target) => {
      for (const item of items) {
        if (item.title === target) return item;
        if (item.children) {
          const found = findNode(item.children, target);
          if (found) return found;
        }
      }
      return null;
    };
    const node = findNode(data, folder);
    if (node && node.children) {
      for (const child of node.children) {
        if (child.children && child.children.length > 0) {
          folders.push(child.title);
        } else if (child.title) {
          files.push(child.title);
        }
      }
    }
  }
  
  const keyboard = [];
  if (folder) {
    keyboard.push([{ text: "â¬…ï¸ è¿”å›æ ¹ç›®å½•", callback_data: "scripts_root_0" }]);
  }
  
  for (const fname of folders) {
    keyboard.push([{ text: "ğŸ“‚ " + fname.slice(0, 28), callback_data: "sdir_" + encodeURIComponent(fname).slice(0, 50) }]);
  }
  
  const pageSize = 5;
  const totalPages = Math.max(1, Math.ceil(files.length / pageSize));
  const p = Math.min(Math.max(0, page), totalPages - 1);
  const pageFiles = files.slice(p * pageSize, (p + 1) * pageSize);
  
  for (const f of pageFiles) {
    const displayName = f.length > 18 ? f.slice(0, 18) + ".." : f;
    const path = folder ? folder + "/" + f : f;
    const encodedPath = encodeURIComponent(path).slice(0, 40);
    keyboard.push([
      { text: "ğŸ“„ " + displayName, callback_data: "scrview_" + encodedPath },
      { text: "â–¶ï¸", callback_data: "scrrun_" + encodedPath },
      { text: "ğŸ—‘ï¸", callback_data: "scrdel_" + encodedPath }
    ]);
  }
  
  if (files.length > pageSize) {
    const nav = [];
    const folderParam = folder ? encodeURIComponent(folder).slice(0, 30) : "";
    if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "scrp_" + folderParam + "_" + (p - 1) });
    nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
    if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "scrp_" + folderParam + "_" + (p + 1) });
    keyboard.push(nav);
  }
  
  keyboard.push([{ text: "ğŸ”„ åˆ·æ–°", callback_data: folder ? "scr_refresh_" + encodeURIComponent(folder).slice(0, 40) : "scr_refresh_root" }]);
  
  const title = folder || "æ ¹ç›®å½•";
  const text = "ğŸ“ <b>è„šæœ¬ç®¡ç† - " + title + "</b>\n\nğŸ“‚ " + folders.length + " æ–‡ä»¶å¤¹ | ğŸ“„ " + files.length + " æ–‡ä»¶";
  
  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: keyboard } });
}

// ==================== å›è°ƒå¤„ç† ====================

async function handleCallback(cb, env) {
  const chatId = cb.message.chat.id;
  const msgId = cb.message.message_id;
  const odl_id = cb.from.id;
  const data = cb.data;
  
  await answerCb(env, cb.id, "â³ å¤„ç†ä¸­...");
  
  if (data === "noop") return;
  
  // è®¾ç½®æµç¨‹
  if (data === "setup_start") {
    return await startSetup(chatId, odl_id, msgId, env);
  }
  if (data === "setup_cancel") {
    userStates.delete(odl_id);
    return await editMsg(env, chatId, msgId, "âŒ å·²å–æ¶ˆè®¾ç½®");
  }
  
  // å¿˜è®° PIN
  if (data === "forget_pin") {
    const kb = {
      inline_keyboard: [
        [{ text: "âš ï¸ ç¡®è®¤åˆ é™¤", callback_data: "confirm_delete_config" }],
        [{ text: "âŒ å–æ¶ˆ", callback_data: "cancel_delete" }]
      ]
    };
    return await editMsg(env, chatId, msgId,
      "âš ï¸ <b>å¿˜è®° PIN ç </b>\n\n" +
      "ç”±äº PIN æœªå­˜å‚¨ï¼Œæ— æ³•æ‰¾å›ã€‚\n" +
      "æ‚¨åªèƒ½åˆ é™¤ç°æœ‰é…ç½®å¹¶é‡æ–°è®¾ç½®ã€‚\n\n" +
      "ç¡®å®šè¦åˆ é™¤æ‚¨çš„é…ç½®å—ï¼Ÿ",
      { reply_markup: kb }
    );
  }
  
  if (data === "confirm_delete_config") {
    await deleteUserConfig(env, odl_id);
    clearSession(odl_id);
    userStates.delete(odl_id);
    return await editMsg(env, chatId, msgId, "âœ… é…ç½®å·²åˆ é™¤ï¼Œè¯·ä½¿ç”¨ /start é‡æ–°è®¾ç½®");
  }
  
  if (data === "cancel_delete") {
    userStates.delete(odl_id);
    return await editMsg(env, chatId, msgId, "âŒ å·²å–æ¶ˆ");
  }
  
  // ç”¨æˆ·é…ç½®æ“ä½œ
  if (data === "lock_session") {
    clearSession(odl_id);
    return await editMsg(env, chatId, msgId, "ğŸ”’ ä¼šè¯å·²é”å®šï¼Œä¸‹æ¬¡æ“ä½œéœ€è¦é‡æ–°è¾“å…¥ PIN");
  }
  
  if (data === "delete_config") {
    const kb = {
      inline_keyboard: [
        [{ text: "âš ï¸ ç¡®è®¤åˆ é™¤", callback_data: "confirm_delete_config" }],
        [{ text: "âŒ å–æ¶ˆ", callback_data: "myconfig_back" }]
      ]
    };
    return await editMsg(env, chatId, msgId,
      "âš ï¸ <b>åˆ é™¤é…ç½®</b>\n\nç¡®å®šè¦åˆ é™¤æ‚¨çš„é’é¾™é¢æ¿é…ç½®å—ï¼Ÿ\næ­¤æ“ä½œä¸å¯æ¢å¤ï¼",
      { reply_markup: kb }
    );
  }
  
  if (data === "myconfig_back") {
    return await cmdMyConfig(chatId, odl_id, env);
  }
  
  if (data === "change_pin") {
    const config = getSession(odl_id);
    if (!config) {
      return await promptUnlock(chatId, odl_id, env);
    }
    userStates.set(odl_id, {
      action: "change_pin",
      chatId,
      msgId,
      config
    });
    return await editMsg(env, chatId, msgId,
      "ğŸ”„ <b>ä¿®æ”¹ PIN</b>\n\nè¯·è¾“å…¥æ–°çš„ 6 ä½æ•°å­— PIN ç \n\n/cancel å–æ¶ˆ"
    );
  }
  
  // ç®¡ç†å‘˜ç”¨æˆ·ç®¡ç†
  if (data.startsWith("users_")) {
    if (!isAdmin(odl_id, env)) return;
    if (data === "users_refresh") {
      return await cmdUsers(chatId, 0, env, msgId);
    }
    const page = parseInt(data.slice(6)) || 0;
    return await cmdUsers(chatId, page, env, msgId);
  }
  
  if (data.startsWith("user_")) {
    if (!isAdmin(odl_id, env)) return;
    const targetId = parseInt(data.slice(5));
    return await showUser(chatId, msgId, targetId, env);
  }
  
  if (data.startsWith("ban_")) {
    if (!isAdmin(odl_id, env)) return;
    const targetId = parseInt(data.slice(4));
    await addToBlacklist(env, targetId);
    clearSession(targetId);
    return await showUser(chatId, msgId, targetId, env);
  }
  
  if (data.startsWith("unban_")) {
    if (!isAdmin(odl_id, env)) return;
    const targetId = parseInt(data.slice(6));
    await removeFromBlacklist(env, targetId);
    return await showUser(chatId, msgId, targetId, env);
  }
  
  if (data.startsWith("admindel_")) {
    if (!isAdmin(odl_id, env)) return;
    const targetId = parseInt(data.slice(9));
    await deleteUserConfig(env, targetId);
    clearSession(targetId);
    return await cmdUsers(chatId, 0, env, msgId);
  }
  
  // éœ€è¦é…ç½®çš„æ“ä½œ
  const config = await getUserConfig(odl_id, env);
  if (!config) {
    const hasConfig = await getUserEncryptedConfig(env, odl_id);
    if (hasConfig) {
      await answerCb(env, cb.id, "ğŸ”’ è¯·å…ˆè§£é”");
      return await promptUnlock(chatId, odl_id, env);
    } else {
      return await promptSetup(chatId, odl_id, env);
    }
  }
  
  // ä»»åŠ¡ç®¡ç†
  if (data.startsWith("tasks_refresh_")) {
    const page = parseInt(data.slice(14)) || 0;
    return await cmdTasks(chatId, odl_id, page, env, config, msgId);
  }
  if (data.startsWith("tasks_")) {
    const page = parseInt(data.slice(6)) || 0;
    return await cmdTasks(chatId, odl_id, page, env, config, msgId);
  }
  if (data.startsWith("cron_")) {
    return await handleCronCallback(chatId, msgId, odl_id, data, env, config);
  }
  if (data === "task_new") {
    userStates.set(odl_id, { action: "new_cron", chatId, msgId });
    return await editMsg(env, chatId, msgId,
      "â• <b>æ–°å»ºä»»åŠ¡</b>\n\næ ¼å¼: <code>åç§°|å‘½ä»¤|å®šæ—¶</code>\nä¾‹: <code>æµ‹è¯•|task test.js|0 8 * * *</code>\n\n/cancel å–æ¶ˆ"
    );
  }
  
  // ç¯å¢ƒå˜é‡
  if (data.startsWith("envs_refresh_")) {
    const page = parseInt(data.slice(13)) || 0;
    return await cmdEnvs(chatId, odl_id, page, env, config, msgId);
  }
  if (data.startsWith("envs_")) {
    const page = parseInt(data.slice(5)) || 0;
    return await cmdEnvs(chatId, odl_id, page, env, config, msgId);
  }
  if (data.startsWith("env_")) {
    return await handleEnvCallback(chatId, msgId, odl_id, data, env, config);
  }
  
  // è®¢é˜…ç®¡ç†
  if (data.startsWith("subs_refresh_")) {
    const page = parseInt(data.slice(13)) || 0;
    return await cmdSubs(chatId, odl_id, page, env, config, msgId);
  }
  if (data.startsWith("subs_")) {
    const page = parseInt(data.slice(5)) || 0;
    return await cmdSubs(chatId, odl_id, page, env, config, msgId);
  }
  if (data.startsWith("sub_")) {
    return await handleSubCallback(chatId, msgId, odl_id, data, env, config);
  }
  
  // ä¾èµ–ç®¡ç†
  if (data === "deps_refresh") {
    return await cmdDeps(chatId, odl_id, env, config, msgId);
  }
  if (data.startsWith("dep_")) {
    return await handleDepCallback(chatId, msgId, odl_id, data, env, config);
  }
  if (data === "deps_main") {
    return await cmdDeps(chatId, odl_id, env, config, msgId);
  }
  
  // è„šæœ¬ç®¡ç†
  if (data.startsWith("scripts_root_")) {
    const page = parseInt(data.slice(13)) || 0;
    return await cmdScripts(chatId, odl_id, "", page, env, config, msgId);
  }
  if (data.startsWith("sdir_")) {
    const folder = decodeURIComponent(data.slice(5));
    return await cmdScripts(chatId, odl_id, folder, 0, env, config, msgId);
  }
  if (data.startsWith("scrp_")) {
    const rest = data.slice(5);
    const lastUnderscore = rest.lastIndexOf("_");
    const folderEncoded = rest.slice(0, lastUnderscore);
    const page = parseInt(rest.slice(lastUnderscore + 1)) || 0;
    const folder = folderEncoded ? decodeURIComponent(folderEncoded) : "";
    return await cmdScripts(chatId, odl_id, folder, page, env, config, msgId);
  }
  if (data.startsWith("scr_refresh_")) {
    const folderPart = data.slice(12);
    const folder = folderPart === "root" ? "" : decodeURIComponent(folderPart);
    return await cmdScripts(chatId, odl_id, folder, 0, env, config, msgId);
  }
  if (data.startsWith("scrview_") || data.startsWith("scrrun_") || data.startsWith("scrdel_")) {
    return await handleScriptCallback(chatId, msgId, odl_id, data, env, config);
  }
}

// ==================== å…·ä½“å›è°ƒå¤„ç† ====================

async function handleCronCallback(chatId, msgId, odl_id, data, env, config) {
  if (data.startsWith("cron_run_")) {
    const id = data.slice(9);
    await qlApi(env, config, odl_id, "PUT", "/open/crons/run", [parseInt(id)]);
    return await showCronDetail(chatId, msgId, odl_id, id, env, config);
  }
  if (data.startsWith("cron_stop_")) {
    const id = data.slice(10);
    await qlApi(env, config, odl_id, "PUT", "/open/crons/stop", [parseInt(id)]);
    return await showCronDetail(chatId, msgId, odl_id, id, env, config);
  }
  if (data.startsWith("cron_en_")) {
    const id = data.slice(8);
    await qlApi(env, config, odl_id, "PUT", "/open/crons/enable", [parseInt(id)]);
    return await showCronDetail(chatId, msgId, odl_id, id, env, config);
  }
  if (data.startsWith("cron_dis_")) {
    const id = data.slice(9);
    await qlApi(env, config, odl_id, "PUT", "/open/crons/disable", [parseInt(id)]);
    return await showCronDetail(chatId, msgId, odl_id, id, env, config);
  }
  if (data.startsWith("cron_del_")) {
    const id = data.slice(9);
    await qlApi(env, config, odl_id, "DELETE", "/open/crons", [parseInt(id)]);
    return await cmdTasks(chatId, odl_id, 0, env, config, msgId);
  }
  if (data.startsWith("cron_log_")) {
    const id = data.slice(9);
    const logRes = await qlApi(env, config, odl_id, "GET", "/open/crons/" + id + "/log", null);
    let logContent = logRes.code === 200 ? (logRes.data || "æš‚æ— æ—¥å¿—") : "è·å–æ—¥å¿—å¤±è´¥";
    if (logContent.length > 3000) {
      logContent = "...(å·²æˆªå–)\n" + logContent.slice(-3000);
    }
    const text = "ğŸ“„ <b>ä»»åŠ¡æ—¥å¿—</b>\n\n<pre>" + escapeHtml(logContent) + "</pre>";
    const kb = [[
      { text: "ğŸ”„ åˆ·æ–°", callback_data: "cron_log_" + id },
      { text: "â¬…ï¸ è¿”å›", callback_data: "cron_" + id }
    ]];
    return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
  }
  if (data.startsWith("cron_edit_")) {
    const id = data.slice(10);
    userStates.set(odl_id, { action: "edit_cron", cronId: id, chatId, msgId });
    return await editMsg(env, chatId, msgId,
      "âœï¸ <b>ç¼–è¾‘å®šæ—¶</b>\n\nè¯·è¾“å…¥æ–°çš„ cron è¡¨è¾¾å¼\nä¾‹: <code>0 8 * * *</code>\n\n/cancel å–æ¶ˆ"
    );
  }
  // æ˜¾ç¤ºä»»åŠ¡è¯¦æƒ…
  const id = data.slice(5);
  return await showCronDetail(chatId, msgId, odl_id, id, env, config);
}

async function showCronDetail(chatId, msgId, odl_id, cronId, env, config) {
  const result = await qlApi(env, config, odl_id, "GET", "/open/crons/" + cronId, null);
  if (result.code !== 200 || !result.data) {
    return await editMsg(env, chatId, msgId, "âŒ ä»»åŠ¡ä¸å­˜åœ¨", {
      reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ è¿”å›", callback_data: "tasks_0" }]] }
    });
  }
  
  const c = result.data;
  const status = c.isDisabled ? "ğŸ”• å·²ç¦ç”¨" : c.isRunning ? "ğŸƒ è¿è¡Œä¸­" : "âœ… å·²å¯ç”¨";
  let text = "ğŸ“‹ <b>" + (c.name || "æœªå‘½å") + "</b>\n\n";
  text += "çŠ¶æ€: " + status + "\n";
  text += "å®šæ—¶: <code>" + (c.schedule || "æ— ") + "</code>\n";
  text += "å‘½ä»¤: <code>" + (c.command || "æ— ") + "</code>";
  
  const kb = [];
  if (c.isRunning) {
    kb.push([{ text: "â¹ï¸ åœæ­¢", callback_data: "cron_stop_" + cronId }]);
  } else {
    kb.push([{ text: "â–¶ï¸ è¿è¡Œ", callback_data: "cron_run_" + cronId }]);
  }
  kb.push([
    c.isDisabled ? { text: "âœ… å¯ç”¨", callback_data: "cron_en_" + cronId } : { text: "ğŸ”• ç¦ç”¨", callback_data: "cron_dis_" + cronId },
    { text: "âœï¸ ç¼–è¾‘", callback_data: "cron_edit_" + cronId }
  ]);
  kb.push([
    { text: "ğŸ“„ æ—¥å¿—", callback_data: "cron_log_" + cronId },
    { text: "ğŸ—‘ï¸ åˆ é™¤", callback_data: "cron_del_" + cronId }
  ]);
  kb.push([{ text: "â¬…ï¸ è¿”å›åˆ—è¡¨", callback_data: "tasks_0" }]);
  
  await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
}

async function handleEnvCallback(chatId, msgId, odl_id, data, env, config) {
  if (data === "env_add") {
    userStates.set(odl_id, { action: "add_env", chatId, msgId });
    return await editMsg(env, chatId, msgId,
      "â• <b>æ·»åŠ å˜é‡</b>\n\næ ¼å¼: <code>åç§°=å€¼</code>\n\n/cancel å–æ¶ˆ"
    );
  }
  if (data.startsWith("env_en_")) {
    const id = data.slice(7);
    await qlApi(env, config, odl_id, "PUT", "/open/envs/enable", [parseInt(id)]);
    return await showEnvDetail(chatId, msgId, odl_id, id, env, config);
  }
  if (data.startsWith("env_dis_")) {
    const id = data.slice(8);
    await qlApi(env, config, odl_id, "PUT", "/open/envs/disable", [parseInt(id)]);
    return await showEnvDetail(chatId, msgId, odl_id, id, env, config);
  }
  if (data.startsWith("env_del_")) {
    const id = data.slice(8);
    await qlApi(env, config, odl_id, "DELETE", "/open/envs", [parseInt(id)]);
    return await cmdEnvs(chatId, odl_id, 0, env, config, msgId);
  }
  if (data.startsWith("env_edit_")) {
    const id = data.slice(9);
    userStates.set(odl_id, { action: "edit_env", envId: id, chatId, msgId });
    return await editMsg(env, chatId, msgId,
      "âœï¸ <b>ç¼–è¾‘å˜é‡</b>\n\næ ¼å¼: <code>åç§°=å€¼</code>\n\n/cancel å–æ¶ˆ"
    );
  }
  // æ˜¾ç¤ºå˜é‡è¯¦æƒ…
  const id = data.slice(4);
  return await showEnvDetail(chatId, msgId, odl_id, id, env, config);
}

async function showEnvDetail(chatId, msgId, odl_id, envId, env, config) {
  const result = await qlApi(env, config, odl_id, "GET", "/open/envs", null);
  const envs = toArray(result);
  const e = envs.find(x => String(x.id) === String(envId));
  
  if (!e) {
    return await editMsg(env, chatId, msgId, "âŒ å˜é‡ä¸å­˜åœ¨", {
      reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ è¿”å›", callback_data: "envs_0" }]] }
    });
  }
  
  const status = e.status === 0 ? "âœ… å·²å¯ç”¨" : "ğŸ”• å·²ç¦ç”¨";
  let text = "ğŸ”‘ <b>" + e.name + "</b>\n\n";
  text += "çŠ¶æ€: " + status + "\n";
  text += "å€¼: <code>" + (e.value || "") + "</code>";
  if (e.remarks) text += "\nå¤‡æ³¨: " + e.remarks;
  
  const kb = [];
  kb.push([e.status === 0 
    ? { text: "ğŸ”• ç¦ç”¨", callback_data: "env_dis_" + envId }
    : { text: "âœ… å¯ç”¨", callback_data: "env_en_" + envId }
  ]);
  kb.push([
    { text: "âœï¸ ç¼–è¾‘", callback_data: "env_edit_" + envId },
    { text: "ğŸ—‘ï¸ åˆ é™¤", callback_data: "env_del_" + envId }
  ]);
  kb.push([{ text: "â¬…ï¸ è¿”å›åˆ—è¡¨", callback_data: "envs_0" }]);
  
  await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
}

async function handleSubCallback(chatId, msgId, odl_id, data, env, config) {
  if (data === "sub_add") {
    userStates.set(odl_id, { action: "add_sub", chatId, msgId });
    return await editMsg(env, chatId, msgId,
      "â• <b>æ·»åŠ è®¢é˜…</b>\n\næ ¼å¼: <code>åç§°|URL|å®šæ—¶|åˆ†æ”¯</code>\n\n/cancel å–æ¶ˆ"
    );
  }
  if (data.startsWith("sub_run_")) {
    const id = data.slice(8);
    await qlApi(env, config, odl_id, "PUT", "/open/subscriptions/run", [parseInt(id)]);
    return await showSubDetail(chatId, msgId, odl_id, id, env, config);
  }
  if (data.startsWith("sub_en_")) {
    const id = data.slice(7);
    await qlApi(env, config, odl_id, "PUT", "/open/subscriptions/enable", [parseInt(id)]);
    return await showSubDetail(chatId, msgId, odl_id, id, env, config);
  }
  if (data.startsWith("sub_dis_")) {
    const id = data.slice(8);
    await qlApi(env, config, odl_id, "PUT", "/open/subscriptions/disable", [parseInt(id)]);
    return await showSubDetail(chatId, msgId, odl_id, id, env, config);
  }
  if (data.startsWith("sub_del_")) {
    const id = data.slice(8);
    await qlApi(env, config, odl_id, "DELETE", "/open/subscriptions", [parseInt(id)]);
    return await cmdSubs(chatId, odl_id, 0, env, config, msgId);
  }
  // æ˜¾ç¤ºè®¢é˜…è¯¦æƒ…
  const id = data.slice(4);
  return await showSubDetail(chatId, msgId, odl_id, id, env, config);
}

async function showSubDetail(chatId, msgId, odl_id, subId, env, config) {
  const result = await qlApi(env, config, odl_id, "GET", "/open/subscriptions", null);
  const subs = toArray(result);
  const s = subs.find(x => String(x.id) === String(subId));
  
  if (!s) {
    return await editMsg(env, chatId, msgId, "âŒ è®¢é˜…ä¸å­˜åœ¨", {
      reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ è¿”å›", callback_data: "subs_0" }]] }
    });
  }
  
  const status = s.is_disabled ? "ğŸ”• å·²ç¦ç”¨" : "âœ… å·²å¯ç”¨";
  let text = "ğŸ“¦ <b>" + s.name + "</b>\n\n";
  text += "çŠ¶æ€: " + status + "\n";
  text += "å®šæ—¶: <code>" + (s.schedule || "æ— ") + "</code>\n";
  text += "URL: <code>" + (s.url || "") + "</code>";
  
  const kb = [];
  kb.push([{ text: "â–¶ï¸ è¿è¡Œ", callback_data: "sub_run_" + subId }]);
  kb.push([s.is_disabled 
    ? { text: "âœ… å¯ç”¨", callback_data: "sub_en_" + subId }
    : { text: "ğŸ”• ç¦ç”¨", callback_data: "sub_dis_" + subId }
  ]);
  kb.push([{ text: "ğŸ—‘ï¸ åˆ é™¤", callback_data: "sub_del_" + subId }]);
  kb.push([{ text: "â¬…ï¸ è¿”å›åˆ—è¡¨", callback_data: "subs_0" }]);
  
  await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
}

async function handleDepCallback(chatId, msgId, odl_id, data, env, config) {
  if (data.startsWith("dep_list_")) {
    const type = data.slice(9);
    return await showDepList(chatId, msgId, odl_id, type, 0, env, config);
  }
  if (data.startsWith("dep_page_")) {
    const rest = data.slice(9);
    const parts = rest.split("_");
    const type = parts[0];
    const page = parseInt(parts[1]) || 0;
    return await showDepList(chatId, msgId, odl_id, type, page, env, config);
  }
  if (data.startsWith("dep_refresh_")) {
    const type = data.slice(12);
    return await showDepList(chatId, msgId, odl_id, type, 0, env, config);
  }
  if (data.startsWith("dep_add_")) {
    const type = data.slice(8);
    userStates.set(odl_id, { action: "add_dep", type, chatId, msgId });
    const typeNames = { python3: "Python", nodejs: "Node.js", linux: "Linux" };
    return await editMsg(env, chatId, msgId,
      "â• <b>æ·»åŠ  " + (typeNames[type] || type) + " ä¾èµ–</b>\n\nè¾“å…¥ä¾èµ–åï¼ˆç©ºæ ¼åˆ†éš”ï¼‰\n\n/cancel å–æ¶ˆ"
    );
  }
  if (data.startsWith("dep_del_")) {
    const rest = data.slice(8);
    const parts = rest.split("_");
    const id = parts[0];
    const type = parts[1];
    await qlApi(env, config, odl_id, "DELETE", "/open/dependencies", [parseInt(id)]);
    return await showDepList(chatId, msgId, odl_id, type, 0, env, config);
  }
}

async function showDepList(chatId, msgId, odl_id, type, page, env, config) {
  const result = await qlApi(env, config, odl_id, "GET", "/open/dependencies?type=" + type, null);
  const deps = toArray(result);
  const typeNames = { python3: "ğŸ Python", nodejs: "ğŸ“¦ Node.js", linux: "ğŸ§ Linux" };
  const typeName = typeNames[type] || type;
  
  if (deps.length === 0) {
    const kb = [
      [{ text: "â• æ·»åŠ ä¾èµ–", callback_data: "dep_add_" + type }],
      [{ text: "â¬…ï¸ è¿”å›", callback_data: "deps_main" }]
    ];
    return await editMsg(env, chatId, msgId, typeName + " <b>ä¾èµ–</b>\n\næš‚æ— ä¾èµ–", { reply_markup: { inline_keyboard: kb } });
  }
  
  const pageSize = 6;
  const totalPages = Math.ceil(deps.length / pageSize);
  const p = Math.min(Math.max(0, page), totalPages - 1);
  const items = deps.slice(p * pageSize, (p + 1) * pageSize);
  
  const keyboard = [];
  for (const d of items) {
    const icon = d.status === 0 ? "âœ…" : d.status === 1 ? "â³" : "âŒ";
    const name = (d.name || "æœªçŸ¥").slice(0, 14);
    keyboard.push([
      { text: icon + " " + name, callback_data: "noop" },
      { text: "ğŸ—‘ï¸", callback_data: "dep_del_" + d.id + "_" + type }
    ]);
  }
  
  const nav = [];
  if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "dep_page_" + type + "_" + (p - 1) });
  nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
  if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "dep_page_" + type + "_" + (p + 1) });
  keyboard.push(nav);
  keyboard.push([
    { text: "â• æ·»åŠ ", callback_data: "dep_add_" + type },
    { text: "ğŸ”„ åˆ·æ–°", callback_data: "dep_refresh_" + type }
  ]);
  keyboard.push([{ text: "â¬…ï¸ è¿”å›", callback_data: "deps_main" }]);
  
  const text = typeName + " <b>ä¾èµ–</b>\n\nå…± " + deps.length + " ä¸ª";
  await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
}

async function handleScriptCallback(chatId, msgId, odl_id, data, env, config) {
  if (data.startsWith("scrview_")) {
    const path = decodeURIComponent(data.slice(8));
    return await sendScriptFile(chatId, msgId, odl_id, path, env, config);
  }
  if (data.startsWith("scrrun_")) {
    const path = decodeURIComponent(data.slice(7));
    const lastSlash = path.lastIndexOf("/");
    const filename = lastSlash >= 0 ? path.slice(lastSlash + 1) : path;
    userStates.set(odl_id, { action: "add_script_cron", filename, path, chatId, msgId });
    return await editMsg(env, chatId, msgId,
      "â° <b>æ·»åŠ åˆ°è¿è¡Œåˆ—è¡¨</b>\n\nè„šæœ¬: <code>" + filename + "</code>\n\nè¯·è¾“å…¥ cron è¡¨è¾¾å¼\næˆ–è¾“å…¥ <code>d</code> ä½¿ç”¨é»˜è®¤\n\n/cancel å–æ¶ˆ"
    );
  }
  if (data.startsWith("scrdel_")) {
    const path = decodeURIComponent(data.slice(7));
    const lastSlash = path.lastIndexOf("/");
    const filename = lastSlash >= 0 ? path.slice(lastSlash + 1) : path;
    const dir = lastSlash >= 0 ? path.slice(0, lastSlash) : "";
    await qlApi(env, config, odl_id, "DELETE", "/open/scripts", { filename, path: dir });
    return await cmdScripts(chatId, odl_id, dir, 0, env, config, msgId);
  }
}

async function sendScriptFile(chatId, msgId, odl_id, path, env, config) {
  const lastSlash = path.lastIndexOf("/");
  const filename = lastSlash >= 0 ? path.slice(lastSlash + 1) : path;
  const dir = lastSlash >= 0 ? path.slice(0, lastSlash) : "";
  
  try {
    await editMsg(env, chatId, msgId, "â³ æ­£åœ¨è·å–: <code>" + escapeHtml(filename) + "</code>...");
    
    const endpoint = "/open/scripts/" + encodeURIComponent(filename) + "?path=" + encodeURIComponent(dir);
    const result = await qlApi(env, config, odl_id, "GET", endpoint, null);
    
    if (result.code !== 200 || !result.data) {
      throw new Error(result.message || "è·å–å¤±è´¥");
    }
    
    const content = result.data;
    const formData = new FormData();
    formData.append("chat_id", String(chatId));
    
    const blob = new Blob([content], { type: "text/plain" });
    formData.append("document", blob, filename);
    
    const sizeKB = (content.length / 1024).toFixed(2);
    let caption = "ğŸ“„ <b>" + escapeHtml(filename) + "</b>\n\n";
    caption += "ğŸ“ è·¯å¾„: <code>" + escapeHtml(path) + "</code>\n";
    caption += "ğŸ“ å¤§å°: " + content.length + " å­—èŠ‚ (" + sizeKB + " KB)";
    
    formData.append("caption", caption);
    formData.append("parse_mode", "HTML");
    
    const resp = await fetch("https://api.telegram.org/bot" + env.TG_BOT_TOKEN + "/sendDocument", {
      method: "POST",
      body: formData
    });
    
    const sendResult = await resp.json();
    if (!sendResult.ok) {
      throw new Error(sendResult.description || "å‘é€å¤±è´¥");
    }
    
    const encodedPath = encodeURIComponent(path).slice(0, 40);
    const kb = [
      [
        { text: "â–¶ï¸ æ·»åŠ ä»»åŠ¡", callback_data: "scrrun_" + encodedPath },
        { text: "ğŸ—‘ï¸ åˆ é™¤", callback_data: "scrdel_" + encodedPath }
      ],
      [
        { text: "ğŸ“¤ é‡å‘", callback_data: "scrview_" + encodedPath },
        { text: "â¬…ï¸ è¿”å›", callback_data: dir ? "sdir_" + encodeURIComponent(dir).slice(0, 50) : "scripts_root_0" }
      ]
    ];
    
    return await editMsg(env, chatId, msgId, "âœ… å·²å‘é€: <b>" + escapeHtml(filename) + "</b>", { reply_markup: { inline_keyboard: kb } });
  } catch (error) {
    const kb = [[{ text: "â¬…ï¸ è¿”å›", callback_data: "scripts_root_0" }]];
    return await editMsg(env, chatId, msgId, "âŒ å¤±è´¥: " + error.message, { reply_markup: { inline_keyboard: kb } });
  }
}

// ==================== çŠ¶æ€è¾“å…¥å¤„ç† ====================

async function handleStateInput(msg, state, env) {
  const chatId = msg.chat.id;
  const odl_id = msg.from.id;
  const text = (msg.text || "").trim();
  const username = msg.from.username;
  const firstName = msg.from.first_name;
  
  if (text === "/cancel") {
    userStates.delete(odl_id);
    return await sendMsg(env, chatId, "âŒ å·²å–æ¶ˆ");
  }
  
  // è§£é”
  if (state.action === "unlock") {
    if (!/^\d{6}$/.test(text)) {
      return await sendMsg(env, chatId, "âŒ PIN å¿…é¡»æ˜¯ 6 ä½æ•°å­—");
    }
    
    const encryptedConfig = await getUserEncryptedConfig(env, odl_id);
    const config = await decryptConfig(encryptedConfig, text, odl_id);
    
    if (!config) {
      state.attempts = (state.attempts || 0) + 1;
      if (state.attempts >= 5) {
        userStates.delete(odl_id);
        return await sendMsg(env, chatId, "âŒ PIN é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œè¯·ç¨åå†è¯•");
      }
      return await sendMsg(env, chatId, "âŒ PIN é”™è¯¯ï¼Œè¿˜å‰© " + (5 - state.attempts) + " æ¬¡æœºä¼š");
    }
    
    setSession(odl_id, config);
    userStates.delete(odl_id);
    
    // æ›´æ–°æœ€åæ´»è·ƒæ—¶é—´
    const meta = await getUserMeta(env, odl_id);
    if (meta) {
      meta.last_active = Date.now();
      await env.USER_CONFIGS.put("meta:" + odl_id, JSON.stringify(meta));
    }
    
    const keyboard = {
      keyboard: [
        [{ text: "ğŸ“‹ ä»»åŠ¡ç®¡ç†" }, { text: "ğŸ”‘ ç¯å¢ƒå˜é‡" }],
        [{ text: "ğŸ“¦ è®¢é˜…ç®¡ç†" }, { text: "ğŸ“š ä¾èµ–ç®¡ç†" }],
        [{ text: "ğŸ“ è„šæœ¬ç®¡ç†" }, { text: "â“ å¸®åŠ©" }]
      ],
      resize_keyboard: true
    };
    
    return await sendMsg(env, chatId, "ğŸ”“ <b>è§£é”æˆåŠŸï¼</b>\n\nè¯·é€‰æ‹©æ“ä½œï¼š", { reply_markup: keyboard });
  }
  
  // è®¾ç½®æµç¨‹ - URL
  if (state.action === "setup_url") {
    if (!text.startsWith("http://") && !text.startsWith("https://")) {
      return await sendMsg(env, chatId, "âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„ URLï¼ˆä»¥ http:// æˆ– https:// å¼€å¤´ï¼‰");
    }
    state.ql_base_url = text.replace(/\/+$/, ""); // ç§»é™¤æœ«å°¾æ–œæ 
    state.action = "setup_client_id";
    userStates.set(odl_id, state);
    return await sendMsg(env, chatId,
      "ğŸ“ <b>æ­¥éª¤ 2/4ï¼šClient ID</b>\n\n" +
      "è¯·è¾“å…¥é’é¾™é¢æ¿çš„ Client ID\n\n" +
      "ğŸ’¡ åœ¨é’é¾™é¢æ¿ ç³»ç»Ÿè®¾ç½® â†’ åº”ç”¨è®¾ç½® ä¸­è·å–\n\n" +
      "/cancel å–æ¶ˆ"
    );
  }
  
  // è®¾ç½®æµç¨‹ - Client ID
  if (state.action === "setup_client_id") {
    if (text.length < 5) {
      return await sendMsg(env, chatId, "âŒ Client ID æ ¼å¼ä¸æ­£ç¡®");
    }
    state.ql_client_id = text;
    state.action = "setup_client_secret";
    userStates.set(odl_id, state);
    return await sendMsg(env, chatId,
      "ğŸ“ <b>æ­¥éª¤ 3/4ï¼šClient Secret</b>\n\n" +
      "è¯·è¾“å…¥é’é¾™é¢æ¿çš„ Client Secret\n\n" +
      "/cancel å–æ¶ˆ"
    );
  }
  
  // è®¾ç½®æµç¨‹ - Client Secret
  if (state.action === "setup_client_secret") {
    if (text.length < 5) {
      return await sendMsg(env, chatId, "âŒ Client Secret æ ¼å¼ä¸æ­£ç¡®");
    }
    state.ql_client_secret = text;
    
    // éªŒè¯è¿æ¥
    await sendMsg(env, chatId, "â³ æ­£åœ¨éªŒè¯è¿æ¥...");
    
    try {
      const testConfig = {
        ql_base_url: state.ql_base_url,
        ql_client_id: state.ql_client_id,
        ql_client_secret: state.ql_client_secret
      };
      await getQlToken(env, testConfig, odl_id);
      
      state.config = testConfig;
      state.action = "setup_pin";
      userStates.set(odl_id, state);
      
      return await sendMsg(env, chatId,
        "âœ… <b>è¿æ¥æˆåŠŸï¼</b>\n\n" +
        "ğŸ“ <b>æ­¥éª¤ 4/4ï¼šè®¾ç½® PIN</b>\n\n" +
        "è¯·è®¾ç½® 6 ä½æ•°å­— PIN ç ç”¨äºåŠ å¯†æ‚¨çš„å‡­è¯\n\n" +
        "âš ï¸ <b>é‡è¦ï¼šè¯·ç‰¢è®°æ­¤ PINï¼Œæ— æ³•æ‰¾å›ï¼</b>\n\n" +
        "/cancel å–æ¶ˆ"
      );
    } catch (error) {
      return await sendMsg(env, chatId,
        "âŒ è¿æ¥å¤±è´¥: " + error.message + "\n\n" +
        "è¯·æ£€æŸ¥é…ç½®åé‡æ–°è¾“å…¥ Client Secret\n\n" +
        "/cancel å–æ¶ˆ"
      );
    }
  }
  
  // è®¾ç½®æµç¨‹ - PIN
  if (state.action === "setup_pin") {
    if (!/^\d{6}$/.test(text)) {
      return await sendMsg(env, chatId, "âŒ PIN å¿…é¡»æ˜¯ 6 ä½æ•°å­—");
    }
    
    await sendMsg(env, chatId, "â³ æ­£åœ¨åŠ å¯†ä¿å­˜...");
    
    const encryptedConfig = await encryptConfig(state.config, text, odl_id);
    const meta = {
      odl_id: odl_id,
      username: username,
      first_name: firstName,
      created_at: Date.now(),
      last_active: Date.now()
    };
    
    await saveUserEncryptedConfig(env, odl_id, encryptedConfig, meta);
    setSession(odl_id, state.config);
    userStates.delete(odl_id);
    
    const keyboard = {
      keyboard: [
        [{ text: "ğŸ“‹ ä»»åŠ¡ç®¡ç†" }, { text: "ğŸ”‘ ç¯å¢ƒå˜é‡" }],
        [{ text: "ğŸ“¦ è®¢é˜…ç®¡ç†" }, { text: "ğŸ“š ä¾èµ–ç®¡ç†" }],
        [{ text: "ğŸ“ è„šæœ¬ç®¡ç†" }, { text: "â“ å¸®åŠ©" }]
      ],
      resize_keyboard: true
    };
    
    return await sendMsg(env, chatId,
      "ğŸ‰ <b>è®¾ç½®å®Œæˆï¼</b>\n\n" +
      "æ‚¨çš„é’é¾™é¢æ¿å·²æˆåŠŸæ·»åŠ å¹¶åŠ å¯†å­˜å‚¨ã€‚\n\n" +
      "è¯·é€‰æ‹©æ“ä½œï¼š",
      { reply_markup: keyboard }
    );
  }
  
  // ä¿®æ”¹ PIN
  if (state.action === "change_pin") {
    if (!/^\d{6}$/.test(text)) {
      return await sendMsg(env, chatId, "âŒ PIN å¿…é¡»æ˜¯ 6 ä½æ•°å­—");
    }
    
    const encryptedConfig = await encryptConfig(state.config, text, odl_id);
    await env.USER_CONFIGS.put("config:" + odl_id, JSON.stringify(encryptedConfig));
    
    userStates.delete(odl_id);
    return await sendMsg(env, chatId, "âœ… PIN å·²ä¿®æ”¹æˆåŠŸ");
  }
  
  // ä»¥ä¸‹éœ€è¦å·²è§£é”çš„é…ç½®
  const config = await getUserConfig(odl_id, env);
  if (!config) {
    userStates.delete(odl_id);
    return await promptUnlock(chatId, odl_id, env);
  }
  
  try {
    // æ–°å»ºä»»åŠ¡
    if (state.action === "new_cron") {
      const parts = text.split("|");
      if (parts.length < 3) {
        return await sendMsg(env, chatId, "âŒ æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨: åç§°|å‘½ä»¤|å®šæ—¶");
      }
      const result = await qlApi(env, config, odl_id, "POST", "/open/crons", {
        name: parts[0].trim(),
        command: parts[1].trim(),
        schedule: parts[2].trim()
      });
      userStates.delete(odl_id);
      if (result.code === 200) {
        return await sendMsg(env, chatId, "âœ… ä»»åŠ¡åˆ›å»ºæˆåŠŸ");
      }
      return await sendMsg(env, chatId, "âŒ åˆ›å»ºå¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }
    
    // ç¼–è¾‘å®šæ—¶
    if (state.action === "edit_cron") {
      const result = await qlApi(env, config, odl_id, "PUT", "/open/crons", {
        id: parseInt(state.cronId),
        schedule: text
      });
      userStates.delete(odl_id);
      if (result.code === 200) {
        return await sendMsg(env, chatId, "âœ… å®šæ—¶å·²æ›´æ–°");
      }
      return await sendMsg(env, chatId, "âŒ æ›´æ–°å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }
    
    // æ·»åŠ ç¯å¢ƒå˜é‡
    if (state.action === "add_env") {
      const eqIndex = text.indexOf("=");
      if (eqIndex < 0) {
        return await sendMsg(env, chatId, "âŒ æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨: åç§°=å€¼");
      }
      const result = await qlApi(env, config, odl_id, "POST", "/open/envs", [{
        name: text.slice(0, eqIndex).trim(),
        value: text.slice(eqIndex + 1).trim()
      }]);
      userStates.delete(odl_id);
      if (result.code === 200) {
        return await sendMsg(env, chatId, "âœ… å˜é‡æ·»åŠ æˆåŠŸ");
      }
      return await sendMsg(env, chatId, "âŒ æ·»åŠ å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }
    
    // ç¼–è¾‘ç¯å¢ƒå˜é‡
    if (state.action === "edit_env") {
      const eqIndex = text.indexOf("=");
      if (eqIndex < 0) {
        return await sendMsg(env, chatId, "âŒ æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨: åç§°=å€¼");
      }
      const result = await qlApi(env, config, odl_id, "PUT", "/open/envs", {
        id: parseInt(state.envId),
        name: text.slice(0, eqIndex).trim(),
        value: text.slice(eqIndex + 1).trim()
      });
      userStates.delete(odl_id);
      if (result.code === 200) {
        return await sendMsg(env, chatId, "âœ… å˜é‡æ›´æ–°æˆåŠŸ");
      }
      return await sendMsg(env, chatId, "âŒ æ›´æ–°å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }
    
    // æ·»åŠ è®¢é˜…
    if (state.action === "add_sub") {
      const parts = text.split("|");
      if (parts.length < 2) {
        return await sendMsg(env, chatId, "âŒ æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨: åç§°|URL|å®šæ—¶|åˆ†æ”¯");
      }
      const body = {
        name: parts[0].trim(),
        url: parts[1].trim(),
        schedule: parts[2] ? parts[2].trim() : "0 0 * * *",
        type: "public-repo"
      };
      if (parts[3]) body.branch = parts[3].trim();
      
      const result = await qlApi(env, config, odl_id, "POST", "/open/subscriptions", body);
      userStates.delete(odl_id);
      if (result.code === 200) {
        return await sendMsg(env, chatId, "âœ… è®¢é˜…æ·»åŠ æˆåŠŸ");
      }
      return await sendMsg(env, chatId, "âŒ æ·»åŠ å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }
    
    // æ·»åŠ ä¾èµ–
    if (state.action === "add_dep") {
      const depNames = text.split(/\s+/);
      const typeMap = { python3: 0, nodejs: 1, linux: 2 };
      const body = depNames.filter(n => n.trim()).map(n => ({
        name: n.trim(),
        type: typeMap[state.type]
      }));
      
      if (body.length === 0) {
        return await sendMsg(env, chatId, "âŒ è¯·è¾“å…¥ä¾èµ–åç§°");
      }
      
      const result = await qlApi(env, config, odl_id, "POST", "/open/dependencies", body);
      userStates.delete(odl_id);
      if (result.code === 200) {
        return await sendMsg(env, chatId, "âœ… ä¾èµ–æ·»åŠ æˆåŠŸ");
      }
      return await sendMsg(env, chatId, "âŒ æ·»åŠ å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }
    
    // æ·»åŠ è„šæœ¬ä»»åŠ¡
    if (state.action === "add_script_cron") {
      const schedule = text.toLowerCase() === "d" ? "0 0 * * *" : text;
      const result = await qlApi(env, config, odl_id, "POST", "/open/crons", {
        name: state.filename,
        command: "task " + state.path,
        schedule
      });
      userStates.delete(odl_id);
      if (result.code === 200) {
        return await sendMsg(env, chatId, "âœ… ä»»åŠ¡åˆ›å»ºæˆåŠŸ");
      }
      return await sendMsg(env, chatId, "âŒ åˆ›å»ºå¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }
  } catch (error) {
    userStates.delete(odl_id);
    return await sendMsg(env, chatId, "âŒ é”™è¯¯: " + error.message);
  }
}

function escapeHtml(text) {
  return String(text).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

export { src_default as default };</code></pre>
        </div>
      </div>
    </div>

    <!-- Usage Tab -->
    <div id="content-usage" class="hidden">
      <div class="grid md:grid-cols-2 gap-6">
        <div class="bg-gray-800 rounded-xl p-6">
          <h3 class="text-xl font-bold text-blue-400 mb-4">ğŸ“‹ éƒ¨ç½²æ­¥éª¤</h3>
          <ol class="space-y-3 text-gray-300">
            <li class="flex gap-3">
              <span class="bg-blue-600 w-6 h-6 rounded-full flex items-center justify-center text-sm shrink-0">1</span>
              <span>åˆ›å»º Cloudflare KV å‘½åç©ºé—´ <code class="bg-gray-700 px-1 rounded">USER_CONFIGS</code></span>
            </li>
            <li class="flex gap-3">
              <span class="bg-blue-600 w-6 h-6 rounded-full flex items-center justify-center text-sm shrink-0">2</span>
              <span>åœ¨ wrangler.toml ä¸­ç»‘å®š KV</span>
            </li>
            <li class="flex gap-3">
              <span class="bg-blue-600 w-6 h-6 rounded-full flex items-center justify-center text-sm shrink-0">3</span>
              <span>è®¾ç½®ç¯å¢ƒå˜é‡ï¼ˆè§å³ä¾§ï¼‰</span>
            </li>
            <li class="flex gap-3">
              <span class="bg-blue-600 w-6 h-6 rounded-full flex items-center justify-center text-sm shrink-0">4</span>
              <span>éƒ¨ç½²å¹¶è®¾ç½® Webhook</span>
            </li>
          </ol>
          
          <div class="mt-4 p-3 bg-gray-700 rounded-lg">
            <p class="text-sm font-mono text-gray-300"># wrangler.toml</p>
            <pre class="text-xs text-green-400 mt-2">[[kv_namespaces]]
binding = "USER_CONFIGS"
id = "your-kv-namespace-id"</pre>
          </div>
        </div>
        
        <div class="bg-gray-800 rounded-xl p-6">
          <h3 class="text-xl font-bold text-green-400 mb-4">ğŸ”§ ç¯å¢ƒå˜é‡</h3>
          <div class="space-y-2 text-sm">
            <div class="bg-gray-700 p-2 rounded">
              <code class="text-yellow-400">TG_BOT_TOKEN</code>
              <span class="text-gray-400 ml-2">Telegram Bot Token</span>
            </div>
            <div class="bg-gray-700 p-2 rounded">
              <code class="text-yellow-400">WEBHOOK_SECRET</code>
              <span class="text-gray-400 ml-2">Webhook éªŒè¯å¯†é’¥</span>
            </div>
            <div class="bg-gray-700 p-2 rounded">
              <code class="text-yellow-400">ADMIN_USER_IDS</code>
              <span class="text-gray-400 ml-2">ç®¡ç†å‘˜ TG IDï¼ˆé€—å·åˆ†éš”ï¼‰</span>
            </div>
            <div class="bg-gray-700 p-2 rounded border-l-2 border-purple-500">
              <code class="text-purple-400">QL_BASE_URL</code>
              <span class="text-gray-400 ml-2">ç®¡ç†å‘˜é»˜è®¤é’é¾™åœ°å€</span>
            </div>
            <div class="bg-gray-700 p-2 rounded border-l-2 border-purple-500">
              <code class="text-purple-400">QL_CLIENT_ID</code>
              <span class="text-gray-400 ml-2">ç®¡ç†å‘˜é»˜è®¤ Client ID</span>
            </div>
            <div class="bg-gray-700 p-2 rounded border-l-2 border-purple-500">
              <code class="text-purple-400">QL_CLIENT_SECRET</code>
              <span class="text-gray-400 ml-2">ç®¡ç†å‘˜é»˜è®¤ Secret</span>
            </div>
          </div>
          <p class="text-xs text-gray-500 mt-3">ç´«è‰²è¾¹æ¡†ï¼šä»…ç®¡ç†å‘˜ä½¿ç”¨çš„é»˜è®¤é…ç½®</p>
        </div>
        
        <div class="bg-gray-800 rounded-xl p-6 md:col-span-2">
          <h3 class="text-xl font-bold text-red-400 mb-4">ğŸ” å®‰å…¨è¯´æ˜</h3>
          <div class="grid md:grid-cols-3 gap-4">
            <div class="bg-gray-700 p-4 rounded-lg">
              <h4 class="font-semibold text-red-300 mb-2">ç«¯åˆ°ç«¯åŠ å¯†</h4>
              <p class="text-gray-400 text-sm">ç”¨æˆ· PIN + UserID æ´¾ç”Ÿ AES-256-GCM å¯†é’¥ï¼ŒPIN ä¸å­˜å‚¨ï¼Œéƒ¨ç½²è€…æ— æ³•è§£å¯†ç”¨æˆ·å‡­è¯</p>
            </div>
            <div class="bg-gray-700 p-4 rounded-lg">
              <h4 class="font-semibold text-yellow-300 mb-2">ä¼šè¯ç®¡ç†</h4>
              <p class="text-gray-400 text-sm">è§£å¯†åçš„é…ç½®ä»…å­˜å†…å­˜ï¼Œ30åˆ†é’Ÿæ— æ“ä½œè‡ªåŠ¨è¿‡æœŸï¼Œç”¨æˆ·å¯ä¸»åŠ¨é”å®š</p>
            </div>
            <div class="bg-gray-700 p-4 rounded-lg">
              <h4 class="font-semibold text-green-300 mb-2">ç”¨æˆ·æ§åˆ¶</h4>
              <p class="text-gray-400 text-sm">ç”¨æˆ·å¯éšæ—¶åˆ é™¤é…ç½®ã€ä¿®æ”¹PINï¼Œç®¡ç†å‘˜å¯ç®¡ç†ç”¨æˆ·ä½†æ— æ³•æŸ¥çœ‹å‡­è¯</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Footer -->
  <footer class="bg-gray-800 mt-12 py-6">
    <div class="max-w-7xl mx-auto px-4 text-center text-gray-400">
      <p>é’é¾™é¢æ¿ Telegram Bot v5.0 - å¤šç”¨æˆ· API ç‰ˆ</p>
      <p class="text-sm mt-2">ğŸ” AES-256-GCM + PBKDF2 ç«¯åˆ°ç«¯åŠ å¯† | ğŸ”Œ RESTful API æ”¯æŒ</p>
    </div>
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
    });

    function showTab(tabName) {
      document.querySelectorAll('[id^="content-"]').forEach(el => {
        el.classList.add('hidden');
      });
      document.querySelectorAll('[id^="tab-"]').forEach(el => {
        el.classList.remove('tab-active');
        el.classList.add('text-gray-400');
      });
      document.getElementById('content-' + tabName).classList.remove('hidden');
      const tab = document.getElementById('tab-' + tabName);
      tab.classList.add('tab-active');
      tab.classList.remove('text-gray-400');
    }

    function copyCode() {
      const code = document.getElementById('full-code').textContent;
      navigator.clipboard.writeText(code).then(() => {
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = 'âœ… å·²å¤åˆ¶!';
        btn.classList.remove('bg-blue-600');
        btn.classList.add('bg-green-600');
        setTimeout(() => {
          btn.textContent = originalText;
          btn.classList.remove('bg-green-600');
          btn.classList.add('bg-blue-600');
        }, 2000);
      });
    }
  </script>
</body>
</html>
