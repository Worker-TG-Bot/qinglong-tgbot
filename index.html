<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>é’é¾™é¢æ¿ Bot v5.3 - å®Œæ•´å¤šç”¨æˆ·ç‰ˆ</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <style>
    .code-container {
      max-height: 70vh;
      overflow-y: auto;
    }
    .code-container::-webkit-scrollbar {
      width: 8px;
    }
    .code-container::-webkit-scrollbar-track {
      background: #1e293b;
    }
    .code-container::-webkit-scrollbar-thumb {
      background: #475569;
      border-radius: 4px;
    }
    .tab-active {
      border-bottom: 2px solid #3b82f6;
      color: #3b82f6;
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
  <header class="bg-gradient-to-r from-blue-900 to-purple-900 shadow-lg">
    <div class="max-w-7xl mx-auto px-4 py-6">
      <div class="flex items-center justify-between flex-wrap gap-4">
        <div class="flex items-center gap-4">
          <span class="text-4xl">ğŸ‰</span>
          <div>
            <h1 class="text-2xl font-bold">é’é¾™é¢æ¿ Telegram Bot</h1>
            <p class="text-blue-200">v5.3 - å®Œæ•´å¤šç”¨æˆ·åŠ å¯†ç‰ˆ + API</p>
          </div>
        </div>
        <div class="flex flex-wrap gap-2">
          <span class="px-3 py-1 bg-green-600 rounded-full text-sm">ğŸ” AES-256åŠ å¯†</span>
          <span class="px-3 py-1 bg-yellow-600 rounded-full text-sm">ğŸ‘¥ å¤šç”¨æˆ·æ”¯æŒ</span>
          <span class="px-3 py-1 bg-purple-600 rounded-full text-sm">ğŸ”Œ REST API</span>
          <span class="px-3 py-1 bg-blue-600 rounded-full text-sm">ğŸ“ è„šæœ¬æ–‡ä»¶å‘é€</span>
        </div>
      </div>
    </div>
  </header>

  <main class="max-w-7xl mx-auto px-4 py-8">
    <!-- Feature Cards -->
    <section class="mb-8 grid md:grid-cols-4 gap-4">
      <div class="bg-gradient-to-br from-green-900/50 to-emerald-900/50 border border-green-700 rounded-xl p-4">
        <h3 class="font-bold text-green-400 mb-2">ğŸ” å®‰å…¨åŠ å¯†</h3>
        <ul class="text-sm text-gray-300 space-y-1">
          <li>â€¢ AES-256-GCM åŠ å¯†</li>
          <li>â€¢ PBKDF2 å¯†é’¥æ´¾ç”Ÿ</li>
          <li>â€¢ PIN ä¸å­˜å‚¨æœåŠ¡å™¨</li>
          <li>â€¢ éƒ¨ç½²è€…æ— æ³•è§£å¯†</li>
        </ul>
      </div>
      <div class="bg-gradient-to-br from-yellow-900/50 to-amber-900/50 border border-yellow-700 rounded-xl p-4">
        <h3 class="font-bold text-yellow-400 mb-2">ğŸ‘¥ å¤šç”¨æˆ·ç³»ç»Ÿ</h3>
        <ul class="text-sm text-gray-300 space-y-1">
          <li>â€¢ KV å¯é€‰ç»‘å®š</li>
          <li>â€¢ ç”¨æˆ·è‡ªåŠ©æ·»åŠ é¢æ¿</li>
          <li>â€¢ ç®¡ç†å‘˜ç”¨æˆ·ç®¡ç†</li>
          <li>â€¢ æ‹‰é»‘/åˆ é™¤ç”¨æˆ·</li>
        </ul>
      </div>
      <div class="bg-gradient-to-br from-purple-900/50 to-indigo-900/50 border border-purple-700 rounded-xl p-4">
        <h3 class="font-bold text-purple-400 mb-2">ğŸ”Œ REST API</h3>
        <ul class="text-sm text-gray-300 space-y-1">
          <li>â€¢ ç¯å¢ƒå˜é‡ CRUD</li>
          <li>â€¢ å®šæ—¶ä»»åŠ¡ç®¡ç†</li>
          <li>â€¢ è®¢é˜…/ä¾èµ–/è„šæœ¬</li>
          <li>â€¢ Bearer è®¤è¯</li>
        </ul>
      </div>
      <div class="bg-gradient-to-br from-blue-900/50 to-cyan-900/50 border border-blue-700 rounded-xl p-4">
        <h3 class="font-bold text-blue-400 mb-2">ğŸ“ è„šæœ¬åŠŸèƒ½</h3>
        <ul class="text-sm text-gray-300 space-y-1">
          <li>â€¢ ç‚¹å‡»å‘é€è„šæœ¬æ–‡ä»¶</li>
          <li>â€¢ æ”¯æŒä¸‹è½½ä¿å­˜</li>
          <li>â€¢ GitHub/Gitee å¯¼å…¥</li>
          <li>â€¢ å¿«æ·æ·»åŠ ä»»åŠ¡</li>
        </ul>
      </div>
    </section>

    <!-- Tabs -->
    <div class="flex gap-4 border-b border-gray-700 mb-6 overflow-x-auto">
      <button onclick="showTab('features')" id="tab-features" class="px-4 py-2 font-medium tab-active whitespace-nowrap">
        âœ¨ åŠŸèƒ½ç‰¹æ€§
      </button>
      <button onclick="showTab('full')" id="tab-full" class="px-4 py-2 font-medium text-gray-400 hover:text-gray-200 whitespace-nowrap">
        ğŸ“œ å®Œæ•´ä»£ç 
      </button>
      <button onclick="showTab('api')" id="tab-api" class="px-4 py-2 font-medium text-gray-400 hover:text-gray-200 whitespace-nowrap">
        ğŸ”Œ API æ–‡æ¡£
      </button>
      <button onclick="showTab('deploy')" id="tab-deploy" class="px-4 py-2 font-medium text-gray-400 hover:text-gray-200 whitespace-nowrap">
        ğŸš€ éƒ¨ç½²è¯´æ˜
      </button>
    </div>

    <!-- Features Tab -->
    <div id="content-features" class="space-y-6">
      <div class="bg-gray-800 rounded-xl p-6">
        <h2 class="text-xl font-bold text-blue-400 mb-4">ğŸ”„ v5.3 æ›´æ–°å†…å®¹</h2>
        <div class="grid md:grid-cols-2 gap-4">
          <div class="bg-gray-700 rounded-lg p-4">
            <h4 class="font-semibold text-green-400 mb-2">âœ… ä¿®å¤å˜é‡åæ··ç”¨</h4>
            <p class="text-sm text-gray-300">ç»Ÿä¸€ä½¿ç”¨ userId å˜é‡åï¼Œä¿®å¤ "userId is not defined" é”™è¯¯ã€‚</p>
          </div>
          <div class="bg-gray-700 rounded-lg p-4">
            <h4 class="font-semibold text-yellow-400 mb-2">âœ… å®Œæ•´ç”¨æˆ·ç®¡ç†</h4>
            <p class="text-sm text-gray-300">/users å‘½ä»¤ + é”®ç›˜æŒ‰é’® + inline æŒ‰é’®ï¼Œç®¡ç†å‘˜å¯æŸ¥çœ‹ã€æ‹‰é»‘ã€åˆ é™¤ç”¨æˆ·ã€‚</p>
          </div>
          <div class="bg-gray-700 rounded-lg p-4">
            <h4 class="font-semibold text-purple-400 mb-2">âœ… æ¢å¤ç¼–è¾‘å®šæ—¶åŠŸèƒ½</h4>
            <p class="text-sm text-gray-300">æ¢å¤"ç¼–è¾‘å®šæ—¶"æ–‡å­—å’Œå–æ¶ˆ inline æŒ‰é’®ï¼Œå®Œæ•´çš„ä»»åŠ¡ç¼–è¾‘ä½“éªŒã€‚</p>
          </div>
          <div class="bg-gray-700 rounded-lg p-4">
            <h4 class="font-semibold text-blue-400 mb-2">âœ… KV å¯é€‰ç»‘å®š</h4>
            <p class="text-sm text-gray-300">è‡ªåŠ¨æ£€æµ‹ KVï¼Œæœªç»‘å®šæ—¶ä»…ç®¡ç†å‘˜å¯ç”¨ï¼Œç»‘å®šåæ”¯æŒå¤šç”¨æˆ·ã€‚</p>
          </div>
        </div>
      </div>

      <div class="bg-gray-800 rounded-xl p-6">
        <h2 class="text-xl font-bold text-yellow-400 mb-4">ğŸ‘¥ ç”¨æˆ·è§’è‰²è¯´æ˜</h2>
        <div class="overflow-x-auto">
          <table class="w-full text-sm">
            <thead>
              <tr class="border-b border-gray-700">
                <th class="text-left py-2 px-4">è§’è‰²</th>
                <th class="text-left py-2 px-4">è®¤è¯æ–¹å¼</th>
                <th class="text-left py-2 px-4">åŠŸèƒ½æƒé™</th>
              </tr>
            </thead>
            <tbody class="text-gray-300">
              <tr class="border-b border-gray-700">
                <td class="py-2 px-4 font-semibold text-green-400">ğŸ‘‘ ç®¡ç†å‘˜</td>
                <td class="py-2 px-4">ADMIN_USER_IDS ç¯å¢ƒå˜é‡</td>
                <td class="py-2 px-4">ä½¿ç”¨é»˜è®¤é’é¾™é…ç½®ï¼Œæ— éœ€ PINï¼Œå¯ç®¡ç†æ‰€æœ‰ç”¨æˆ·</td>
              </tr>
              <tr class="border-b border-gray-700">
                <td class="py-2 px-4 font-semibold text-blue-400">ğŸ‘¤ æ™®é€šç”¨æˆ·</td>
                <td class="py-2 px-4">è‡ªåŠ©æ·»åŠ  + PIN è§£é”</td>
                <td class="py-2 px-4">ç®¡ç†è‡ªå·±çš„é’é¾™é¢æ¿ï¼Œå¯åˆ é™¤é…ç½®</td>
              </tr>
              <tr>
                <td class="py-2 px-4 font-semibold text-red-400">ğŸš« è¢«æ‹‰é»‘ç”¨æˆ·</td>
                <td class="py-2 px-4">-</td>
                <td class="py-2 px-4">æ— æ³•ä½¿ç”¨ä»»ä½•åŠŸèƒ½</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="bg-gray-800 rounded-xl p-6">
        <h2 class="text-xl font-bold text-purple-400 mb-4">ğŸ” åŠ å¯†åŸç†</h2>
        <div class="bg-gray-900 rounded-lg p-4 font-mono text-sm">
          <p class="text-gray-400 mb-2">// åŠ å¯†æµç¨‹</p>
          <p class="text-green-400">1. ç”¨æˆ·è®¾ç½® 6ä½ PINï¼ˆä¸å­˜å‚¨åˆ°æœåŠ¡å™¨ï¼‰</p>
          <p class="text-green-400">2. ä½¿ç”¨ PBKDF2 ä» PIN + UserID æ´¾ç”Ÿå¯†é’¥ï¼ˆ100,000æ¬¡è¿­ä»£ï¼‰</p>
          <p class="text-green-400">3. ç”Ÿæˆéšæœº IVï¼ˆ12å­—èŠ‚ï¼‰</p>
          <p class="text-green-400">4. ä½¿ç”¨ AES-256-GCM åŠ å¯†é’é¾™å‡­è¯</p>
          <p class="text-green-400">5. å­˜å‚¨: IV + å¯†æ–‡ + AuthTag åˆ° KV</p>
          <p class="text-gray-400 mt-2">// è§£å¯†æ—¶</p>
          <p class="text-blue-400">ç”¨æˆ·è¾“å…¥ PIN â†’ æ´¾ç”Ÿå¯†é’¥ â†’ è§£å¯† â†’ éªŒè¯ AuthTag</p>
          <p class="text-red-400 mt-2">âš ï¸ é”™è¯¯çš„ PIN æ— æ³•è§£å¯†ï¼Œéƒ¨ç½²è€…ä¹Ÿæ— æ³•æŸ¥çœ‹ç”¨æˆ·å‡­è¯</p>
        </div>
      </div>
    </div>

    <!-- Full Code Tab -->
    <div id="content-full" class="hidden">
      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-gray-700 px-4 py-3 flex items-center justify-between">
          <h3 class="font-semibold">ğŸ“œ å®Œæ•´ä»£ç  (index.js)</h3>
          <button onclick="copyCode()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm transition">
            ğŸ“‹ å¤åˆ¶ä»£ç 
          </button>
        </div>
        <div class="code-container p-4">
          <pre><code class="language-javascript" id="full-code"></code></pre>
        </div>
      </div>
    </div>

    <!-- API Tab -->
    <div id="content-api" class="hidden space-y-6">
      <div class="bg-gray-800 rounded-xl p-6">
        <h2 class="text-xl font-bold text-yellow-400 mb-4">ğŸ”Œ API è®¤è¯</h2>
        <p class="text-gray-300 mb-4">æ‰€æœ‰ API è¯·æ±‚éœ€è¦åœ¨ Header ä¸­æºå¸¦è®¤è¯ï¼š</p>
        <pre class="bg-gray-900 p-4 rounded-lg text-sm overflow-x-auto"><code>Authorization: Bearer YOUR_API_SECRET</code></pre>
        <p class="text-gray-400 text-sm mt-3">Base URL: <code class="bg-gray-700 px-2 py-1 rounded">https://your-worker.workers.dev/api</code></p>
      </div>

      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-green-900 px-4 py-3">
          <h3 class="font-semibold">ğŸ”‘ ç¯å¢ƒå˜é‡ API</h3>
        </div>
        <div class="p-4 space-y-3 text-sm">
          <div class="flex items-center gap-2 bg-gray-700 p-3 rounded">
            <span class="px-2 py-1 bg-blue-600 rounded text-xs font-bold">GET</span>
            <code class="text-yellow-400">/api/envs</code>
            <span class="text-gray-400 ml-auto">è·å–æ‰€æœ‰ç¯å¢ƒå˜é‡</span>
          </div>
          <div class="flex items-center gap-2 bg-gray-700 p-3 rounded">
            <span class="px-2 py-1 bg-green-600 rounded text-xs font-bold">POST</span>
            <code class="text-yellow-400">/api/envs</code>
            <span class="text-gray-400 ml-auto">æ·»åŠ ç¯å¢ƒå˜é‡</span>
          </div>
          <div class="flex items-center gap-2 bg-gray-700 p-3 rounded">
            <span class="px-2 py-1 bg-yellow-600 rounded text-xs font-bold">PUT</span>
            <code class="text-yellow-400">/api/envs/:id</code>
            <span class="text-gray-400 ml-auto">æ›´æ–°ç¯å¢ƒå˜é‡</span>
          </div>
          <div class="flex items-center gap-2 bg-gray-700 p-3 rounded">
            <span class="px-2 py-1 bg-red-600 rounded text-xs font-bold">DELETE</span>
            <code class="text-yellow-400">/api/envs/:id</code>
            <span class="text-gray-400 ml-auto">åˆ é™¤ç¯å¢ƒå˜é‡</span>
          </div>
        </div>
      </div>

      <div class="bg-gray-800 rounded-xl overflow-hidden">
        <div class="bg-blue-900 px-4 py-3">
          <h3 class="font-semibold">ğŸ“‹ å®šæ—¶ä»»åŠ¡ API</h3>
        </div>
        <div class="p-4 space-y-3 text-sm">
          <div class="flex items-center gap-2 bg-gray-700 p-3 rounded">
            <span class="px-2 py-1 bg-blue-600 rounded text-xs font-bold">GET</span>
            <code class="text-yellow-400">/api/crons</code>
            <span class="text-gray-400 ml-auto">è·å–æ‰€æœ‰ä»»åŠ¡</span>
          </div>
          <div class="flex items-center gap-2 bg-gray-700 p-3 rounded">
            <span class="px-2 py-1 bg-green-600 rounded text-xs font-bold">POST</span>
            <code class="text-yellow-400">/api/crons</code>
            <span class="text-gray-400 ml-auto">åˆ›å»ºä»»åŠ¡</span>
          </div>
          <div class="flex items-center gap-2 bg-gray-700 p-3 rounded">
            <span class="px-2 py-1 bg-purple-600 rounded text-xs font-bold">PUT</span>
            <code class="text-yellow-400">/api/crons/:id/run</code>
            <span class="text-gray-400 ml-auto">è¿è¡Œä»»åŠ¡</span>
          </div>
          <div class="flex items-center gap-2 bg-gray-700 p-3 rounded">
            <span class="px-2 py-1 bg-orange-600 rounded text-xs font-bold">PUT</span>
            <code class="text-yellow-400">/api/crons/:id/stop</code>
            <span class="text-gray-400 ml-auto">åœæ­¢ä»»åŠ¡</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Deploy Tab -->
    <div id="content-deploy" class="hidden">
      <div class="grid md:grid-cols-2 gap-6">
        <div class="bg-gray-800 rounded-xl p-6">
          <h3 class="text-xl font-bold text-blue-400 mb-4">ğŸ“‹ éƒ¨ç½²æ­¥éª¤</h3>
          <ol class="space-y-3 text-gray-300">
            <li class="flex gap-3">
              <span class="bg-blue-600 w-6 h-6 rounded-full flex items-center justify-center text-sm shrink-0">1</span>
              <span>åˆ›å»º Cloudflare Worker</span>
            </li>
            <li class="flex gap-3">
              <span class="bg-blue-600 w-6 h-6 rounded-full flex items-center justify-center text-sm shrink-0">2</span>
              <span>å¤åˆ¶å®Œæ•´ä»£ç åˆ° Worker</span>
            </li>
            <li class="flex gap-3">
              <span class="bg-blue-600 w-6 h-6 rounded-full flex items-center justify-center text-sm shrink-0">3</span>
              <span>è®¾ç½®ç¯å¢ƒå˜é‡ï¼ˆå¿…éœ€ï¼‰</span>
            </li>
            <li class="flex gap-3">
              <span class="bg-blue-600 w-6 h-6 rounded-full flex items-center justify-center text-sm shrink-0">4</span>
              <span>ï¼ˆå¯é€‰ï¼‰åˆ›å»ºå¹¶ç»‘å®š KV å‘½åç©ºé—´</span>
            </li>
            <li class="flex gap-3">
              <span class="bg-blue-600 w-6 h-6 rounded-full flex items-center justify-center text-sm shrink-0">5</span>
              <span>è®¿é—® /set-webhook?secret=xxx è®¾ç½® Webhook</span>
            </li>
          </ol>
        </div>

        <div class="bg-gray-800 rounded-xl p-6">
          <h3 class="text-xl font-bold text-green-400 mb-4">ğŸ”§ ç¯å¢ƒå˜é‡</h3>
          <div class="space-y-2 text-sm">
            <div class="bg-gray-700 p-2 rounded border-l-2 border-red-500">
              <code class="text-yellow-400">TG_BOT_TOKEN</code>
              <span class="text-gray-400 ml-2">å¿…éœ€ - Bot Token</span>
            </div>
            <div class="bg-gray-700 p-2 rounded border-l-2 border-red-500">
              <code class="text-yellow-400">WEBHOOK_SECRET</code>
              <span class="text-gray-400 ml-2">å¿…éœ€ - Webhook å¯†é’¥</span>
            </div>
            <div class="bg-gray-700 p-2 rounded border-l-2 border-red-500">
              <code class="text-yellow-400">ADMIN_USER_IDS</code>
              <span class="text-gray-400 ml-2">å¿…éœ€ - ç®¡ç†å‘˜ ID</span>
            </div>
            <div class="bg-gray-700 p-2 rounded border-l-2 border-red-500">
              <code class="text-yellow-400">QL_BASE_URL</code>
              <span class="text-gray-400 ml-2">å¿…éœ€ - é’é¾™åœ°å€</span>
            </div>
            <div class="bg-gray-700 p-2 rounded border-l-2 border-red-500">
              <code class="text-yellow-400">QL_CLIENT_ID</code>
              <span class="text-gray-400 ml-2">å¿…éœ€ - Client ID</span>
            </div>
            <div class="bg-gray-700 p-2 rounded border-l-2 border-red-500">
              <code class="text-yellow-400">QL_CLIENT_SECRET</code>
              <span class="text-gray-400 ml-2">å¿…éœ€ - Client Secret</span>
            </div>
            <div class="bg-gray-700 p-2 rounded border-l-2 border-yellow-500">
              <code class="text-yellow-400">API_SECRET</code>
              <span class="text-gray-400 ml-2">å¯é€‰ - REST API å¯†é’¥</span>
            </div>
          </div>
        </div>

        <div class="bg-gray-800 rounded-xl p-6 md:col-span-2">
          <h3 class="text-xl font-bold text-yellow-400 mb-4">ğŸ“¦ KV ç»‘å®šï¼ˆå¯é€‰ï¼‰</h3>
          <p class="text-gray-300 mb-4">å¦‚éœ€æ”¯æŒå¤šç”¨æˆ·ï¼Œè¯·åˆ›å»º KV å‘½åç©ºé—´å¹¶ç»‘å®šï¼š</p>
          <pre class="bg-gray-900 p-4 rounded-lg text-sm overflow-x-auto"><code class="text-green-400"># wrangler.toml
[[kv_namespaces]]
binding = "USER_CONFIGS"
id = "your-kv-namespace-id"</code></pre>
          <div class="mt-4 p-4 bg-blue-900/30 border border-blue-700 rounded-lg">
            <p class="text-blue-300 text-sm">ğŸ’¡ æœªç»‘å®š KV æ—¶ï¼ŒBot ä»…ç®¡ç†å‘˜å¯ç”¨ã€‚ç»‘å®šåæ”¯æŒå¤šç”¨æˆ·è‡ªåŠ©æ·»åŠ é’é¾™é¢æ¿ã€‚</p>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer class="bg-gray-800 mt-12 py-6">
    <div class="max-w-7xl mx-auto px-4 text-center text-gray-400">
      <p>é’é¾™é¢æ¿ Telegram Bot v5.3 - å®Œæ•´å¤šç”¨æˆ·åŠ å¯†ç‰ˆ</p>
      <p class="text-sm mt-2">ğŸ” AES-256åŠ å¯† | ğŸ‘¥ å¤šç”¨æˆ·æ”¯æŒ | ğŸ”Œ REST API | ğŸ“ è„šæœ¬æ–‡ä»¶å‘é€</p>
    </div>
  </footer>

  <script id="code-template" type="text/plain">
// é’é¾™é¢æ¿ Bot v5.3 - å®Œæ•´å¤šç”¨æˆ·åŠ å¯†ç‰ˆ + API
// æ”¯æŒï¼šKVå¯é€‰ç»‘å®šã€å¤šç”¨æˆ·åŠ å¯†ã€ç®¡ç†å‘˜ç”¨æˆ·ç®¡ç†ã€REST APIã€è„šæœ¬æ–‡ä»¶å‘é€

var BOT_COMMANDS = [
  { command: "start", description: "å¼€å§‹ä½¿ç”¨" },
  { command: "tasks", description: "ä»»åŠ¡ç®¡ç†" },
  { command: "envs", description: "ç¯å¢ƒå˜é‡" },
  { command: "subs", description: "è®¢é˜…ç®¡ç†" },
  { command: "deps", description: "ä¾èµ–ç®¡ç†" },
  { command: "scripts", description: "è„šæœ¬ç®¡ç†" },
  { command: "users", description: "ç”¨æˆ·ç®¡ç†(ç®¡ç†å‘˜)" },
  { command: "myconfig", description: "æˆ‘çš„é…ç½®" },
  { command: "help", description: "å¸®åŠ©ä¿¡æ¯" }
];

var userStates = new Map();
var userSessions = new Map();
var qlTokenCache = new Map();
var REQUEST_TIMEOUT = 15000;
var SESSION_TIMEOUT = 30 * 60 * 1000;

// ==================== Worker å…¥å£ ====================

export default {
  async fetch(request, env, ctx) {
    var url = new URL(request.url);
    
    if (url.pathname.startsWith("/api")) {
      return await handleApiRequest(request, url, env);
    }
    
    if (url.pathname === "/set-webhook") {
      return handleSetWebhook(url, env);
    }
    
    if (url.pathname === "/delete-webhook") {
      return handleDeleteWebhook(url, env);
    }
    
    if (url.pathname === "/set-commands") {
      return handleSetCommands(url, env);
    }
    
    if (url.pathname === "/health") {
      var kvStatus = env.USER_CONFIGS ? "å·²ç»‘å®š" : "æœªç»‘å®š";
      return new Response("OK - v5.3 | KV: " + kvStatus);
    }
    
    if (url.pathname === "/webhook" && request.method === "POST") {
      try {
        var update = await request.json();
        console.log("Received update:", JSON.stringify(update).slice(0, 500));
        ctx.waitUntil(processUpdate(update, env));
        return new Response("OK");
      } catch (e) {
        console.error("Webhook error:", e);
        return new Response("Error", { status: 500 });
      }
    }
    
    return new Response("Qinglong Bot v5.3 Multi-user");
  }
};

// ==================== Webhook ç®¡ç† ====================

async function handleSetWebhook(url, env) {
  if (url.searchParams.get("secret") !== env.WEBHOOK_SECRET) {
    return new Response("Unauthorized", { status: 401 });
  }
  var webhookUrl = url.origin + "/webhook";
  var resp = await tgApi(env.TG_BOT_TOKEN, "setWebhook", {
    url: webhookUrl,
    allowed_updates: ["message", "callback_query"]
  });
  return new Response(JSON.stringify({ webhookUrl: webhookUrl, result: resp }, null, 2));
}

async function handleDeleteWebhook(url, env) {
  if (url.searchParams.get("secret") !== env.WEBHOOK_SECRET) {
    return new Response("Unauthorized", { status: 401 });
  }
  var resp = await tgApi(env.TG_BOT_TOKEN, "deleteWebhook");
  return new Response(JSON.stringify(resp, null, 2));
}

async function handleSetCommands(url, env) {
  if (url.searchParams.get("secret") !== env.WEBHOOK_SECRET) {
    return new Response("Unauthorized", { status: 401 });
  }
  var resp = await tgApi(env.TG_BOT_TOKEN, "setMyCommands", { commands: BOT_COMMANDS });
  return new Response(JSON.stringify(resp, null, 2));
}

// ==================== API å¤„ç† ====================

async function handleApiRequest(request, url, env) {
  if (request.method === "OPTIONS") {
    return new Response(null, {
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization"
      }
    });
  }

  var authHeader = request.headers.get("Authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ") || authHeader.slice(7) !== env.API_SECRET) {
    return jsonResponse({ error: true, message: "Unauthorized" }, 401);
  }

  var path = url.pathname.replace("/api", "");
  var qlConfig = { baseUrl: env.QL_BASE_URL, clientId: env.QL_CLIENT_ID, clientSecret: env.QL_CLIENT_SECRET };

  try {
    if (path === "/envs" && request.method === "GET") {
      return jsonResponse(await qlApi(env, qlConfig, "admin", "GET", "/open/envs", null));
    }
    if (path === "/envs" && request.method === "POST") {
      var body = await request.json();
      return jsonResponse(await qlApi(env, qlConfig, "admin", "POST", "/open/envs", [body]));
    }
    if (path.match(/^\/envs\/\d+$/) && request.method === "PUT") {
      var id = path.split("/")[2];
      var body = await request.json();
      body.id = parseInt(id);
      return jsonResponse(await qlApi(env, qlConfig, "admin", "PUT", "/open/envs", body));
    }
    if (path.match(/^\/envs\/\d+$/) && request.method === "DELETE") {
      var id = path.split("/")[2];
      return jsonResponse(await qlApi(env, qlConfig, "admin", "DELETE", "/open/envs", [parseInt(id)]));
    }
    if (path.match(/^\/envs\/\d+\/enable$/) && request.method === "PUT") {
      var id = path.split("/")[2];
      return jsonResponse(await qlApi(env, qlConfig, "admin", "PUT", "/open/envs/enable", [parseInt(id)]));
    }
    if (path.match(/^\/envs\/\d+\/disable$/) && request.method === "PUT") {
      var id = path.split("/")[2];
      return jsonResponse(await qlApi(env, qlConfig, "admin", "PUT", "/open/envs/disable", [parseInt(id)]));
    }
    if (path === "/crons" && request.method === "GET") {
      return jsonResponse(await qlApi(env, qlConfig, "admin", "GET", "/open/crons", null));
    }
    if (path === "/crons" && request.method === "POST") {
      var body = await request.json();
      return jsonResponse(await qlApi(env, qlConfig, "admin", "POST", "/open/crons", body));
    }
    if (path.match(/^\/crons\/\d+$/) && request.method === "PUT") {
      var id = path.split("/")[2];
      var cronRes = await qlApi(env, qlConfig, "admin", "GET", "/open/crons/" + id, null);
      if (cronRes.code !== 200 || !cronRes.data) {
        return jsonResponse({ error: true, message: "Cron not found" }, 404);
      }
      var cron = cronRes.data;
      var body = await request.json();
      var updateData = {
        id: parseInt(id),
        name: body.name || cron.name,
        command: body.command || cron.command,
        schedule: body.schedule || cron.schedule,
        labels: body.labels || cron.labels || []
      };
      return jsonResponse(await qlApi(env, qlConfig, "admin", "PUT", "/open/crons", updateData));
    }
    if (path.match(/^\/crons\/\d+$/) && request.method === "DELETE") {
      var id = path.split("/")[2];
      return jsonResponse(await qlApi(env, qlConfig, "admin", "DELETE", "/open/crons", [parseInt(id)]));
    }
    if (path.match(/^\/crons\/\d+\/run$/) && request.method === "PUT") {
      var id = path.split("/")[2];
      return jsonResponse(await qlApi(env, qlConfig, "admin", "PUT", "/open/crons/run", [parseInt(id)]));
    }
    if (path.match(/^\/crons\/\d+\/stop$/) && request.method === "PUT") {
      var id = path.split("/")[2];
      return jsonResponse(await qlApi(env, qlConfig, "admin", "PUT", "/open/crons/stop", [parseInt(id)]));
    }
    if (path.match(/^\/crons\/\d+\/log$/) && request.method === "GET") {
      var id = path.split("/")[2];
      return jsonResponse(await qlApi(env, qlConfig, "admin", "GET", "/open/crons/" + id + "/log", null));
    }
    if (path === "/subscriptions" && request.method === "GET") {
      return jsonResponse(await qlApi(env, qlConfig, "admin", "GET", "/open/subscriptions", null));
    }
    if (path === "/subscriptions" && request.method === "POST") {
      var body = await request.json();
      return jsonResponse(await qlApi(env, qlConfig, "admin", "POST", "/open/subscriptions", body));
    }
    if (path === "/scripts" && request.method === "GET") {
      return jsonResponse(await qlApi(env, qlConfig, "admin", "GET", "/open/scripts", null));
    }
    if (path === "/dependencies" && request.method === "GET") {
      var type = url.searchParams.get("type") || "nodejs";
      return jsonResponse(await qlApi(env, qlConfig, "admin", "GET", "/open/dependencies?type=" + type, null));
    }
    return jsonResponse({ error: true, message: "Not Found" }, 404);
  } catch (e) {
    return jsonResponse({ error: true, message: e.message }, 500);
  }
}

function jsonResponse(data, status) {
  return new Response(JSON.stringify(data), {
    status: status || 200,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}

// ==================== Telegram API ====================

async function tgApi(token, method, body) {
  var resp = await fetch("https://api.telegram.org/bot" + token + "/" + method, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body || {})
  });
  return resp.json();
}

async function sendMsg(env, chatId, text, opts) {
  return tgApi(env.TG_BOT_TOKEN, "sendMessage", Object.assign({
    chat_id: chatId,
    text: text,
    parse_mode: "HTML"
  }, opts || {}));
}

async function editMsg(env, chatId, msgId, text, opts) {
  return tgApi(env.TG_BOT_TOKEN, "editMessageText", Object.assign({
    chat_id: chatId,
    message_id: msgId,
    text: text,
    parse_mode: "HTML"
  }, opts || {}));
}

async function answerCb(env, cbId, text) {
  return tgApi(env.TG_BOT_TOKEN, "answerCallbackQuery", {
    callback_query_id: cbId,
    text: text || ""
  });
}

// ==================== åŠ å¯†å‡½æ•° ====================

async function deriveKey(pin, visitorId) {
  var enc = new TextEncoder();
  var keyMaterial = await crypto.subtle.importKey(
    "raw", enc.encode(pin + ":" + visitorId), "PBKDF2", false, ["deriveKey"]
  );
  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt: enc.encode("ql-bot-salt-v2:" + visitorId), iterations: 100000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}

async function encryptData(data, pin, visitorId) {
  var key = await deriveKey(pin, visitorId);
  var enc = new TextEncoder();
  var iv = crypto.getRandomValues(new Uint8Array(12));
  var encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, enc.encode(JSON.stringify(data)));
  var combined = new Uint8Array(iv.length + encrypted.byteLength);
  combined.set(iv);
  combined.set(new Uint8Array(encrypted), iv.length);
  return btoa(String.fromCharCode.apply(null, combined));
}

async function decryptData(encryptedStr, pin, visitorId) {
  try {
    var key = await deriveKey(pin, visitorId);
    var combined = Uint8Array.from(atob(encryptedStr), function(c) { return c.charCodeAt(0); });
    var iv = combined.slice(0, 12);
    var data = combined.slice(12);
    var decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, data);
    return JSON.parse(new TextDecoder().decode(decrypted));
  } catch (e) {
    return null;
  }
}

// ==================== ç”¨æˆ·é…ç½®ç®¡ç† ====================

function isAdmin(userId, env) {
  if (!env.ADMIN_USER_IDS) return false;
  return env.ADMIN_USER_IDS.split(",").map(function(s) { return s.trim(); }).includes(String(userId));
}

function hasKV(env) {
  return env.USER_CONFIGS !== undefined && env.USER_CONFIGS !== null;
}

async function getUserConfig(env, visitorId) {
  if (!hasKV(env)) return null;
  try {
    var data = await env.USER_CONFIGS.get("user:" + visitorId);
    if (!data) return null;
    return JSON.parse(data);
  } catch (e) {
    return null;
  }
}

async function saveUserConfig(env, visitorId, config) {
  if (!hasKV(env)) return false;
  await env.USER_CONFIGS.put("user:" + visitorId, JSON.stringify(config));
  return true;
}

async function deleteUserConfig(env, visitorId) {
  if (!hasKV(env)) return false;
  await env.USER_CONFIGS.delete("user:" + visitorId);
  return true;
}

async function getAllUsers(env) {
  if (!hasKV(env)) return [];
  var list = await env.USER_CONFIGS.list({ prefix: "user:" });
  var users = [];
  for (var i = 0; i < list.keys.length; i++) {
    var key = list.keys[i].name;
    var visitorId = key.replace("user:", "");
    var data = await env.USER_CONFIGS.get(key);
    if (data) {
      var config = JSON.parse(data);
      users.push({
        visitorId: visitorId,
        createdAt: config.createdAt,
        banned: config.banned || false
      });
    }
  }
  return users;
}

async function isUserBanned(env, userId) {
  var config = await getUserConfig(env, userId);
  return config && config.banned === true;
}

// ==================== é’é¾™ API ====================

async function getQlToken(env, qlConfig, visitorId) {
  var cacheKey = visitorId + ":" + qlConfig.baseUrl;
  var cached = qlTokenCache.get(cacheKey);
  var now = Date.now();
  if (cached && cached.expiry > now + 300000) {
    return cached.token;
  }

  var url = qlConfig.baseUrl + "/open/auth/token?client_id=" + qlConfig.clientId + "&client_secret=" + qlConfig.clientSecret;
  var controller = new AbortController();
  var timeoutId = setTimeout(function() { controller.abort(); }, 8000);

  try {
    var resp = await fetch(url, { signal: controller.signal });
    clearTimeout(timeoutId);
    var data = await resp.json();
    if (data.code === 200) {
      qlTokenCache.set(cacheKey, {
        token: data.data.token,
        expiry: now + data.data.expiration * 1000 - 120000
      });
      return data.data.token;
    }
    throw new Error("è·å–Tokenå¤±è´¥: " + (data.message || "æœªçŸ¥é”™è¯¯"));
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === "AbortError") throw new Error("è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥é’é¾™åœ°å€");
    throw error;
  }
}

async function qlApi(env, qlConfig, visitorId, method, endpoint, body) {
  var token = await getQlToken(env, qlConfig, visitorId);
  var controller = new AbortController();
  var timeoutId = setTimeout(function() { controller.abort(); }, REQUEST_TIMEOUT);

  try {
    var opts = {
      method: method,
      headers: { "Authorization": "Bearer " + token, "Content-Type": "application/json" },
      signal: controller.signal
    };
    if (body !== undefined && body !== null) {
      opts.body = JSON.stringify(body);
    }
    var resp = await fetch(qlConfig.baseUrl + endpoint, opts);
    clearTimeout(timeoutId);
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    return resp.json();
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === "AbortError") throw new Error("è¯·æ±‚è¶…æ—¶");
    throw error;
  }
}

// ==================== è·å–ç”¨æˆ·çš„é’é¾™é…ç½® ====================

function getQlConfigForUser(env, userId) {
  if (isAdmin(userId, env)) {
    return {
      baseUrl: env.QL_BASE_URL,
      clientId: env.QL_CLIENT_ID,
      clientSecret: env.QL_CLIENT_SECRET
    };
  }
  var session = userSessions.get(String(userId));
  if (session && session.expiry > Date.now()) {
    return session.qlConfig;
  }
  return null;
}

// ==================== æ¶ˆæ¯å¤„ç† ====================

async function processUpdate(update, env) {
  try {
    var userId, chatId;
    if (update.callback_query) {
      userId = update.callback_query.from.id;
      chatId = update.callback_query.message.chat.id;
    } else if (update.message) {
      userId = update.message.from.id;
      chatId = update.message.chat.id;
    } else {
      return;
    }

    console.log("Processing for user:", userId, "isAdmin:", isAdmin(userId, env));

    if (await isUserBanned(env, userId)) {
      await sendMsg(env, chatId, "â›” æ‚¨å·²è¢«ç®¡ç†å‘˜ç¦æ­¢ä½¿ç”¨");
      return;
    }

    if (update.callback_query) {
      await handleCallback(update.callback_query, env);
    } else if (update.message) {
      await handleMessage(update.message, env);
    }
  } catch (error) {
    console.error("Process error:", error);
    var errChatId = update.message?.chat?.id || update.callback_query?.message?.chat?.id;
    if (errChatId) {
      await sendMsg(env, errChatId, "âŒ é”™è¯¯: " + error.message);
    }
  }
}

async function handleMessage(msg, env) {
  var chatId = msg.chat.id;
  var userId = msg.from.id;
  var text = (msg.text || "").trim();

  console.log("Message from", userId, ":", text);

  var state = userStates.get(userId);
  if (state) {
    await handleStateInput(msg, state, env);
    return;
  }

  if (msg.document) {
    if (!await checkUserAccess(env, chatId, userId)) return;
    await handleDocument(msg, env);
    return;
  }

  if (text && (text.includes("github.com") || text.includes("raw.githubusercontent.com") ||
      text.includes("gitee.com") || text.match(/https?:\/\/.*\.(js|py|sh|ts)$/i))) {
    if (!await checkUserAccess(env, chatId, userId)) return;
    await handleFileUrl(msg, env);
    return;
  }

  if (text.indexOf("ä»»åŠ¡ç®¡ç†") >= 0) {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return await cmdTasks(chatId, userId, 0, env, null);
  }
  if (text.indexOf("ç¯å¢ƒå˜é‡") >= 0) {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return await cmdEnvs(chatId, userId, 0, env, null);
  }
  if (text.indexOf("è®¢é˜…ç®¡ç†") >= 0) {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return await cmdSubs(chatId, userId, 0, env, null);
  }
  if (text.indexOf("ä¾èµ–ç®¡ç†") >= 0) {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return await cmdDeps(chatId, userId, env, null);
  }
  if (text.indexOf("è„šæœ¬ç®¡ç†") >= 0) {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return await cmdScripts(chatId, userId, "", 0, env, null);
  }
  if (text.indexOf("å¸®åŠ©") >= 0) {
    return await cmdHelp(chatId, userId, env);
  }
  if (text.indexOf("ç”¨æˆ·ç®¡ç†") >= 0) {
    if (!isAdmin(userId, env)) {
      return await sendMsg(env, chatId, "â›” ä»…ç®¡ç†å‘˜å¯ç”¨");
    }
    return await cmdUsers(chatId, 0, env, null);
  }

  if (text.startsWith("/")) {
    var cmd = text.split(" ")[0].split("@")[0];
    console.log("Command:", cmd);

    switch (cmd) {
      case "/start":
        return await cmdStart(chatId, userId, env);
      case "/help":
        return await cmdHelp(chatId, userId, env);
      case "/tasks":
        if (!await checkUserAccess(env, chatId, userId)) return;
        return await cmdTasks(chatId, userId, 0, env, null);
      case "/envs":
        if (!await checkUserAccess(env, chatId, userId)) return;
        return await cmdEnvs(chatId, userId, 0, env, null);
      case "/subs":
        if (!await checkUserAccess(env, chatId, userId)) return;
        return await cmdSubs(chatId, userId, 0, env, null);
      case "/deps":
        if (!await checkUserAccess(env, chatId, userId)) return;
        return await cmdDeps(chatId, userId, env, null);
      case "/scripts":
        if (!await checkUserAccess(env, chatId, userId)) return;
        return await cmdScripts(chatId, userId, "", 0, env, null);
      case "/users":
        if (!isAdmin(userId, env)) {
          return await sendMsg(env, chatId, "â›” ä»…ç®¡ç†å‘˜å¯ç”¨");
        }
        return await cmdUsers(chatId, 0, env, null);
      case "/myconfig":
        return await cmdMyConfig(chatId, userId, env);
      case "/cancel":
        userStates.delete(userId);
        return await sendMsg(env, chatId, "âŒ å·²å–æ¶ˆ");
    }
  }

  console.log("No handler matched");
}

async function checkUserAccess(env, chatId, userId) {
  if (isAdmin(userId, env)) return true;

  var session = userSessions.get(String(userId));
  if (session && session.expiry > Date.now()) {
    return true;
  }

  if (!hasKV(env)) {
    await sendMsg(env, chatId,
      "â›” æœªæˆæƒ\n\næ‚¨çš„ ID: <code>" + userId + "</code>\n\nå½“å‰ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨æ­¤ Bot"
    );
    return false;
  }

  var config = await getUserConfig(env, userId);
  if (!config) {
    var kb = { inline_keyboard: [[
      { text: "âœ… æ·»åŠ æˆ‘çš„é’é¾™é¢æ¿", callback_data: "setup_start" },
      { text: "âŒ å–æ¶ˆ", callback_data: "noop" }
    ]] };
    await sendMsg(env, chatId,
      "ğŸ‘‹ æ¬¢è¿ä½¿ç”¨é’é¾™é¢æ¿ Bot\n\n" +
      "æ‚¨å°šæœªé…ç½®é’é¾™é¢æ¿\næ˜¯å¦æ·»åŠ æ‚¨è‡ªå·±çš„é’é¾™é¢æ¿ï¼Ÿ\n\n" +
      "ğŸ” æ‚¨çš„å‡­è¯å°†ä½¿ç”¨ AES-256 åŠ å¯†å­˜å‚¨\nåªæœ‰æ‚¨è®¾ç½®çš„ PIN æ‰èƒ½è§£é”",
      { reply_markup: kb }
    );
    return false;
  }

  userStates.set(userId, { action: "unlock_pin", chatId: chatId });
  await sendMsg(env, chatId,
    "ğŸ” è¯·è¾“å…¥æ‚¨çš„ 6 ä½ PIN ç è§£é”\n\n/cancel å–æ¶ˆ"
  );
  return false;
}

// ==================== å‘½ä»¤å¤„ç† ====================

async function cmdStart(chatId, userId, env) {
  var isAdminUser = isAdmin(userId, env);
  var keyboard = {
    keyboard: [
      [{ text: "ğŸ“‹ ä»»åŠ¡ç®¡ç†" }, { text: "ğŸ”‘ ç¯å¢ƒå˜é‡" }],
      [{ text: "ğŸ“¦ è®¢é˜…ç®¡ç†" }, { text: "ğŸ“š ä¾èµ–ç®¡ç†" }],
      [{ text: "ğŸ“ è„šæœ¬ç®¡ç†" }, { text: "â“ å¸®åŠ©" }]
    ],
    resize_keyboard: true,
    persistent: true
  };
  if (isAdminUser) {
    keyboard.keyboard.push([{ text: "ğŸ‘¥ ç”¨æˆ·ç®¡ç†" }]);
  }

  var text = "ğŸ‰ <b>é’é¾™é¢æ¿ Bot v5.3</b>\n\n";
  if (isAdminUser) {
    text += "ğŸ‘‘ ç®¡ç†å‘˜æ¨¡å¼\n";
    text += "ä½¿ç”¨é»˜è®¤é’é¾™é…ç½®\n\n";
  } else if (hasKV(env)) {
    text += "ğŸ‘¤ å¤šç”¨æˆ·æ¨¡å¼\n";
    text += "è¯·å…ˆé…ç½®æ‚¨çš„é’é¾™é¢æ¿\n\n";
  } else {
    text += "âš ï¸ ä»…ç®¡ç†å‘˜æ¨¡å¼\n";
    text += "KV æœªç»‘å®šï¼Œä¸æ”¯æŒå¤šç”¨æˆ·\n\n";
  }
  text += "è¯·é€‰æ‹©æ“ä½œæˆ–ä½¿ç”¨å‘½ä»¤";

  await sendMsg(env, chatId, text, { reply_markup: keyboard });
}

async function cmdHelp(chatId, userId, env) {
  var isAdminUser = isAdmin(userId, env);
  var text = "ğŸ‰ <b>é’é¾™é¢æ¿ Bot å¸®åŠ©</b>\n\n";
  text += "<b>ğŸ“Œ åŸºæœ¬å‘½ä»¤</b>\n";
  text += "/start - å¼€å§‹ä½¿ç”¨\n";
  text += "/tasks - ğŸ“‹ ä»»åŠ¡ç®¡ç†\n";
  text += "/envs - ğŸ”‘ ç¯å¢ƒå˜é‡\n";
  text += "/subs - ğŸ“¦ è®¢é˜…ç®¡ç†\n";
  text += "/deps - ğŸ“š ä¾èµ–ç®¡ç†\n";
  text += "/scripts - ğŸ“ è„šæœ¬ç®¡ç†\n";
  text += "/myconfig - âš™ï¸ æˆ‘çš„é…ç½®\n";
  text += "/help - â“ å¸®åŠ©ä¿¡æ¯\n\n";

  if (isAdminUser) {
    text += "<b>ğŸ‘‘ ç®¡ç†å‘˜å‘½ä»¤</b>\n";
    text += "/users - ğŸ‘¥ ç”¨æˆ·ç®¡ç†\n\n";
  }

  text += "<b>ğŸ“¤ æ·»åŠ è„šæœ¬æ–¹å¼</b>\n";
  text += "1. ç›´æ¥å‘é€ .js/.py/.sh/.ts æ–‡ä»¶\n";
  text += "2. å‘é€ GitHub/Gitee æ–‡ä»¶é“¾æ¥\n\n";

  text += "<b>ğŸ” å®‰å…¨è¯´æ˜</b>\n";
  text += "â€¢ å‡­è¯ä½¿ç”¨ AES-256-GCM åŠ å¯†\n";
  text += "â€¢ PIN ä¸å­˜å‚¨ï¼Œæ— æ³•è¢«ä»»ä½•äººæŸ¥çœ‹\n";
  text += "â€¢ ä¼šè¯ 30 åˆ†é’Ÿåè‡ªåŠ¨é”å®š";

  var kb = { inline_keyboard: [] };
  kb.inline_keyboard.push([
    { text: "ğŸ“‹ ä»»åŠ¡", callback_data: "cmd_tasks" },
    { text: "ğŸ”‘ ç¯å¢ƒå˜é‡", callback_data: "cmd_envs" },
    { text: "ğŸ“¦ è®¢é˜…", callback_data: "cmd_subs" }
  ]);
  kb.inline_keyboard.push([
    { text: "ğŸ“š ä¾èµ–", callback_data: "cmd_deps" },
    { text: "ğŸ“ è„šæœ¬", callback_data: "cmd_scripts" }
  ]);
  if (isAdminUser) {
    kb.inline_keyboard.push([{ text: "ğŸ‘¥ ç”¨æˆ·ç®¡ç†", callback_data: "cmd_users" }]);
  }

  await sendMsg(env, chatId, text, { reply_markup: kb });
}

async function cmdMyConfig(chatId, userId, env) {
  if (isAdmin(userId, env)) {
    var kb = { inline_keyboard: [[{ text: "ğŸ”„ æµ‹è¯•è¿æ¥", callback_data: "test_connection" }]] };
    return await sendMsg(env, chatId,
      "ğŸ‘‘ <b>ç®¡ç†å‘˜é…ç½®</b>\n\n" +
      "ä½¿ç”¨ç¯å¢ƒå˜é‡ä¸­çš„é»˜è®¤é’é¾™é…ç½®\n\n" +
      "åœ°å€: <code>" + (env.QL_BASE_URL || "æœªè®¾ç½®") + "</code>",
      { reply_markup: kb }
    );
  }

  if (!hasKV(env)) {
    return await sendMsg(env, chatId, "âš ï¸ KV æœªç»‘å®šï¼Œä¸æ”¯æŒç”¨æˆ·é…ç½®");
  }

  var config = await getUserConfig(env, userId);
  if (!config) {
    var kb = { inline_keyboard: [[{ text: "âœ… æ·»åŠ é…ç½®", callback_data: "setup_start" }]] };
    return await sendMsg(env, chatId, "æ‚¨å°šæœªé…ç½®é’é¾™é¢æ¿", { reply_markup: kb });
  }

  var sessionActive = userSessions.has(String(userId));
  var kb = { inline_keyboard: [
    [{ text: "ğŸ”„ æµ‹è¯•è¿æ¥", callback_data: "test_connection" }],
    [{ text: "ğŸ—‘ï¸ åˆ é™¤æˆ‘çš„é…ç½®", callback_data: "delete_my_config" }]
  ] };
  await sendMsg(env, chatId,
    "âš™ï¸ <b>æˆ‘çš„é…ç½®</b>\n\n" +
    "çŠ¶æ€: " + (sessionActive ? "ğŸ”“ å·²è§£é”" : "ğŸ” å·²é”å®š") + "\n" +
    "æ·»åŠ æ—¶é—´: " + new Date(config.createdAt).toLocaleString("zh-CN"),
    { reply_markup: kb }
  );
}

// ==================== ç”¨æˆ·ç®¡ç† ====================

async function cmdUsers(chatId, page, env, msgId) {
  var users = await getAllUsers(env);

  if (users.length === 0) {
    var text = "ğŸ‘¥ <b>ç”¨æˆ·ç®¡ç†</b>\n\næš‚æ— ç”¨æˆ·";
    var kb = { inline_keyboard: [[{ text: "ğŸ”„ åˆ·æ–°", callback_data: "users_refresh" }]] };
    if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: kb });
    return await sendMsg(env, chatId, text, { reply_markup: kb });
  }

  var pageSize = 8;
  var totalPages = Math.ceil(users.length / pageSize);
  var p = Math.min(Math.max(0, page), totalPages - 1);
  var items = users.slice(p * pageSize, (p + 1) * pageSize);

  var keyboard = [];
  for (var i = 0; i < items.length; i++) {
    var u = items[i];
    var icon = u.banned ? "ğŸš«" : "ğŸ‘¤";
    keyboard.push([{ text: icon + " " + u.visitorId, callback_data: "user_" + u.visitorId }]);
  }

  var nav = [];
  if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "users_" + (p - 1) });
  nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
  if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "users_" + (p + 1) });
  keyboard.push(nav);
  keyboard.push([{ text: "ğŸ”„ åˆ·æ–°", callback_data: "users_refresh" }]);

  var text = "ğŸ‘¥ <b>ç”¨æˆ·ç®¡ç†</b>\n\nå…± " + users.length + " ä¸ªç”¨æˆ·";
  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: keyboard } });
}

async function showUserDetail(chatId, msgId, targetUserId, env) {
  var config = await getUserConfig(env, targetUserId);
  if (!config) {
    return await editMsg(env, chatId, msgId, "âŒ ç”¨æˆ·ä¸å­˜åœ¨", {
      reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ è¿”å›", callback_data: "users_0" }]] }
    });
  }

  var status = config.banned ? "ğŸš« å·²æ‹‰é»‘" : "âœ… æ­£å¸¸";
  var text = "ğŸ‘¤ <b>ç”¨æˆ·è¯¦æƒ…</b>\n\n";
  text += "ID: <code>" + targetUserId + "</code>\n";
  text += "çŠ¶æ€: " + status + "\n";
  text += "æ·»åŠ æ—¶é—´: " + new Date(config.createdAt).toLocaleString("zh-CN");

  var kb = [];
  if (config.banned) {
    kb.push([{ text: "âœ… è§£é™¤æ‹‰é»‘", callback_data: "user_unban_" + targetUserId }]);
  } else {
    kb.push([{ text: "ğŸš« æ‹‰é»‘ç”¨æˆ·", callback_data: "user_ban_" + targetUserId }]);
  }
  kb.push([{ text: "ğŸ—‘ï¸ åˆ é™¤ç”¨æˆ·", callback_data: "user_del_" + targetUserId }]);
  kb.push([{ text: "â¬…ï¸ è¿”å›åˆ—è¡¨", callback_data: "users_0" }]);

  await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
}

// ==================== å·¥å…·å‡½æ•° ====================

function toArray(result) {
  if (!result || result.code !== 200) return [];
  var d = result.data;
  if (Array.isArray(d)) return d;
  if (d && Array.isArray(d.data)) return d.data;
  return [];
}

function escapeHtml(text) {
  return String(text).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// ==================== ä»»åŠ¡ç®¡ç† ====================

async function cmdTasks(chatId, userId, page, env, msgId) {
  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var result = await qlApi(env, qlConfig, userId, "GET", "/open/crons", null);
  var crons = toArray(result);

  if (crons.length === 0) {
    var text = "ğŸ“‹ <b>ä»»åŠ¡ç®¡ç†</b>\n\næš‚æ— ä»»åŠ¡";
    var kb = { inline_keyboard: [[{ text: "â• æ–°å»ºä»»åŠ¡", callback_data: "task_new" }]] };
    if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: kb });
    return await sendMsg(env, chatId, text, { reply_markup: kb });
  }

  var pageSize = 8;
  var totalPages = Math.ceil(crons.length / pageSize);
  var p = Math.min(Math.max(0, page), totalPages - 1);
  var items = crons.slice(p * pageSize, (p + 1) * pageSize);

  var keyboard = [];
  for (var i = 0; i < items.length; i++) {
    var c = items[i];
    var icon = c.isDisabled ? "ğŸ”•" : c.isRunning ? "ğŸƒ" : "âœ…";
    var name = (c.name || "æœªå‘½å").slice(0, 22);
    keyboard.push([{ text: icon + " " + name, callback_data: "cron_" + c.id }]);
  }

  var nav = [];
  if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "tasks_" + (p - 1) });
  nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
  if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "tasks_" + (p + 1) });
  keyboard.push(nav);
  keyboard.push([
    { text: "ğŸ”„ åˆ·æ–°", callback_data: "tasks_refresh_" + p },
    { text: "â• æ–°å»º", callback_data: "task_new" }
  ]);

  var running = crons.filter(function(c) { return c.isRunning; }).length;
  var enabled = crons.filter(function(c) { return !c.isDisabled; }).length;
  var text = "ğŸ“‹ <b>ä»»åŠ¡ç®¡ç†</b>\n\nå…± " + crons.length + " ä¸ª | âœ…" + enabled + " ğŸƒ" + running;

  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: keyboard } });
}

async function showCron(chatId, msgId, cronId, userId, env) {
  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var result = await qlApi(env, qlConfig, userId, "GET", "/open/crons/" + cronId, null);
  if (result.code !== 200 || !result.data) {
    return await editMsg(env, chatId, msgId, "âŒ ä»»åŠ¡ä¸å­˜åœ¨", {
      reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ è¿”å›", callback_data: "tasks_0" }]] }
    });
  }

  var c = result.data;
  var status = c.isDisabled ? "ğŸ”• å·²ç¦ç”¨" : c.isRunning ? "ğŸƒ è¿è¡Œä¸­" : "âœ… å·²å¯ç”¨";
  var text = "ğŸ“‹ <b>" + (c.name || "æœªå‘½å") + "</b>\n\n";
  text += "çŠ¶æ€: " + status + "\n";
  text += "å®šæ—¶: <code>" + (c.schedule || "æ— ") + "</code>\n";
  text += "å‘½ä»¤: <code>" + (c.command || "æ— ") + "</code>";

  var kb = [];
  if (c.isRunning) {
    kb.push([{ text: "â¹ï¸ åœæ­¢è¿è¡Œ", callback_data: "cron_stop_" + cronId }]);
  } else {
    kb.push([{ text: "â–¶ï¸ è¿è¡Œä»»åŠ¡", callback_data: "cron_run_" + cronId }]);
  }
  kb.push([
    c.isDisabled ? { text: "âœ… å¯ç”¨", callback_data: "cron_en_" + cronId } : { text: "ğŸ”• ç¦ç”¨", callback_data: "cron_dis_" + cronId },
    { text: "âœï¸ ç¼–è¾‘å®šæ—¶", callback_data: "cron_edit_" + cronId }
  ]);
  kb.push([
    { text: "ğŸ“„ æŸ¥çœ‹æ—¥å¿—", callback_data: "cron_log_" + cronId },
    { text: "ğŸ—‘ï¸ åˆ é™¤", callback_data: "cron_del_" + cronId }
  ]);
  kb.push([{ text: "â¬…ï¸ è¿”å›åˆ—è¡¨", callback_data: "tasks_0" }]);

  await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
}

// ==================== ç¯å¢ƒå˜é‡ ====================

async function cmdEnvs(chatId, userId, page, env, msgId) {
  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var result = await qlApi(env, qlConfig, userId, "GET", "/open/envs", null);
  var envs = toArray(result);

  if (envs.length === 0) {
    var text = "ğŸ”‘ <b>ç¯å¢ƒå˜é‡</b>\n\næš‚æ— å˜é‡";
    var kb = { inline_keyboard: [[{ text: "â• æ·»åŠ å˜é‡", callback_data: "env_add" }]] };
    if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: kb });
    return await sendMsg(env, chatId, text, { reply_markup: kb });
  }

  var pageSize = 8;
  var totalPages = Math.ceil(envs.length / pageSize);
  var p = Math.min(Math.max(0, page), totalPages - 1);
  var items = envs.slice(p * pageSize, (p + 1) * pageSize);

  var keyboard = [];
  for (var i = 0; i < items.length; i++) {
    var e = items[i];
    var icon = e.status === 0 ? "âœ…" : "ğŸ”•";
    var name = (e.name || "æœªå‘½å").slice(0, 22);
    keyboard.push([{ text: icon + " " + name, callback_data: "env_" + e.id }]);
  }

  var nav = [];
  if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "envs_" + (p - 1) });
  nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
  if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "envs_" + (p + 1) });
  keyboard.push(nav);
  keyboard.push([
    { text: "â• æ·»åŠ ", callback_data: "env_add" },
    { text: "ğŸ”„ åˆ·æ–°", callback_data: "envs_refresh_" + p }
  ]);

  var text = "ğŸ”‘ <b>ç¯å¢ƒå˜é‡</b>\n\nå…± " + envs.length + " ä¸ª";
  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: keyboard } });
}

async function showEnv(chatId, msgId, envId, userId, env) {
  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var result = await qlApi(env, qlConfig, userId, "GET", "/open/envs", null);
  var envs = toArray(result);
  var e = envs.find(function(x) { return String(x.id) === String(envId); });

  if (!e) {
    return await editMsg(env, chatId, msgId, "âŒ å˜é‡ä¸å­˜åœ¨", {
      reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ è¿”å›", callback_data: "envs_0" }]] }
    });
  }

  var status = e.status === 0 ? "âœ… å·²å¯ç”¨" : "ğŸ”• å·²ç¦ç”¨";
  var text = "ğŸ”‘ <b>" + e.name + "</b>\n\n";
  text += "çŠ¶æ€: " + status + "\n";
  text += "å€¼: <code>" + (e.value || "") + "</code>";
  if (e.remarks) text += "\nå¤‡æ³¨: " + e.remarks;

  var kb = [];
  kb.push([e.status === 0
    ? { text: "ğŸ”• ç¦ç”¨", callback_data: "env_dis_" + envId }
    : { text: "âœ… å¯ç”¨", callback_data: "env_en_" + envId }
  ]);
  kb.push([
    { text: "âœï¸ ç¼–è¾‘", callback_data: "env_edit_" + envId },
    { text: "ğŸ—‘ï¸ åˆ é™¤", callback_data: "env_del_" + envId }
  ]);
  kb.push([{ text: "â¬…ï¸ è¿”å›åˆ—è¡¨", callback_data: "envs_0" }]);

  await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
}

// ==================== è®¢é˜…ç®¡ç† ====================

async function cmdSubs(chatId, userId, page, env, msgId) {
  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var result = await qlApi(env, qlConfig, userId, "GET", "/open/subscriptions", null);
  var subs = toArray(result);

  if (subs.length === 0) {
    var text = "ğŸ“¦ <b>è®¢é˜…ç®¡ç†</b>\n\næš‚æ— è®¢é˜…";
    var kb = { inline_keyboard: [[{ text: "â• æ·»åŠ è®¢é˜…", callback_data: "sub_add" }]] };
    if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: kb });
    return await sendMsg(env, chatId, text, { reply_markup: kb });
  }

  var pageSize = 8;
  var totalPages = Math.ceil(subs.length / pageSize);
  var p = Math.min(Math.max(0, page), totalPages - 1);
  var items = subs.slice(p * pageSize, (p + 1) * pageSize);

  var keyboard = [];
  for (var i = 0; i < items.length; i++) {
    var s = items[i];
    var icon = s.is_disabled ? "ğŸ”•" : "âœ…";
    var name = (s.name || "æœªå‘½å").slice(0, 22);
    keyboard.push([{ text: icon + " " + name, callback_data: "sub_" + s.id }]);
  }

  var nav = [];
  if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "subs_" + (p - 1) });
  nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
  if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "subs_" + (p + 1) });
  keyboard.push(nav);
  keyboard.push([
    { text: "â• æ·»åŠ ", callback_data: "sub_add" },
    { text: "ğŸ”„ åˆ·æ–°", callback_data: "subs_refresh_" + p }
  ]);

  var text = "ğŸ“¦ <b>è®¢é˜…ç®¡ç†</b>\n\nå…± " + subs.length + " ä¸ª";
  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: keyboard } });
}

async function showSub(chatId, msgId, subId, userId, env) {
  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var result = await qlApi(env, qlConfig, userId, "GET", "/open/subscriptions", null);
  var subs = toArray(result);
  var s = subs.find(function(x) { return String(x.id) === String(subId); });

  if (!s) {
    return await editMsg(env, chatId, msgId, "âŒ è®¢é˜…ä¸å­˜åœ¨", {
      reply_markup: { inline_keyboard: [[{ text: "â¬…ï¸ è¿”å›", callback_data: "subs_0" }]] }
    });
  }

  var status = s.is_disabled ? "ğŸ”• å·²ç¦ç”¨" : "âœ… å·²å¯ç”¨";
  var text = "ğŸ“¦ <b>" + s.name + "</b>\n\n";
  text += "çŠ¶æ€: " + status + "\n";
  text += "å®šæ—¶: <code>" + (s.schedule || "æ— ") + "</code>\n";
  text += "URL: <code>" + (s.url || "") + "</code>";

  var kb = [];
  kb.push([{ text: "â–¶ï¸ è¿è¡Œ", callback_data: "sub_run_" + subId }]);
  kb.push([s.is_disabled
    ? { text: "âœ… å¯ç”¨", callback_data: "sub_en_" + subId }
    : { text: "ğŸ”• ç¦ç”¨", callback_data: "sub_dis_" + subId }
  ]);
  kb.push([{ text: "ğŸ—‘ï¸ åˆ é™¤", callback_data: "sub_del_" + subId }]);
  kb.push([{ text: "â¬…ï¸ è¿”å›åˆ—è¡¨", callback_data: "subs_0" }]);

  await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
}

// ==================== ä¾èµ–ç®¡ç† ====================

async function cmdDeps(chatId, userId, env, msgId) {
  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var results = await Promise.allSettled([
    qlApi(env, qlConfig, userId, "GET", "/open/dependencies?type=python3", null),
    qlApi(env, qlConfig, userId, "GET", "/open/dependencies?type=nodejs", null),
    qlApi(env, qlConfig, userId, "GET", "/open/dependencies?type=linux", null)
  ]);

  var pythonDeps = results[0].status === "fulfilled" ? toArray(results[0].value) : [];
  var nodeDeps = results[1].status === "fulfilled" ? toArray(results[1].value) : [];
  var linuxDeps = results[2].status === "fulfilled" ? toArray(results[2].value) : [];
  var total = pythonDeps.length + nodeDeps.length + linuxDeps.length;

  var kb = [
    [{ text: "ğŸ Python (" + pythonDeps.length + ")", callback_data: "dep_list_python3" }],
    [{ text: "ğŸ“¦ Node.js (" + nodeDeps.length + ")", callback_data: "dep_list_nodejs" }],
    [{ text: "ğŸ§ Linux (" + linuxDeps.length + ")", callback_data: "dep_list_linux" }],
    [{ text: "ğŸ”„ åˆ·æ–°", callback_data: "deps_refresh" }]
  ];

  var text = "ğŸ“š <b>ä¾èµ–ç®¡ç†</b>\n\nå…± " + total + " ä¸ªä¾èµ–";
  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: kb } });
}

async function showDepList(chatId, msgId, type, page, userId, env) {
  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var result = await qlApi(env, qlConfig, userId, "GET", "/open/dependencies?type=" + type, null);
  var deps = toArray(result);
  var typeNames = { python3: "ğŸ Python", nodejs: "ğŸ“¦ Node.js", linux: "ğŸ§ Linux" };
  var typeName = typeNames[type] || type;

  if (deps.length === 0) {
    var kb = [
      [{ text: "â• æ·»åŠ ä¾èµ–", callback_data: "dep_add_" + type }],
      [{ text: "â¬…ï¸ è¿”å›", callback_data: "deps_main" }]
    ];
    return await editMsg(env, chatId, msgId, typeName + " <b>ä¾èµ–</b>\n\næš‚æ— ä¾èµ–", { reply_markup: { inline_keyboard: kb } });
  }

  var pageSize = 6;
  var totalPages = Math.ceil(deps.length / pageSize);
  var p = Math.min(Math.max(0, page), totalPages - 1);
  var items = deps.slice(p * pageSize, (p + 1) * pageSize);

  var keyboard = [];
  for (var i = 0; i < items.length; i++) {
    var d = items[i];
    var icon = d.status === 0 ? "âœ…" : d.status === 1 ? "â³" : "âŒ";
    var name = (d.name || "æœªçŸ¥").slice(0, 14);
    keyboard.push([
      { text: icon + " " + name, callback_data: "noop" },
      { text: "ğŸ”„", callback_data: "dep_reinstall_" + d.id + "_" + type },
      { text: "ğŸ—‘ï¸", callback_data: "dep_del_" + d.id + "_" + type }
    ]);
  }

  var nav = [];
  if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "dep_page_" + type + "_" + (p - 1) });
  nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
  if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "dep_page_" + type + "_" + (p + 1) });
  keyboard.push(nav);
  keyboard.push([
    { text: "â• æ·»åŠ ", callback_data: "dep_add_" + type },
    { text: "ğŸ”„ åˆ·æ–°", callback_data: "dep_refresh_" + type }
  ]);
  keyboard.push([{ text: "â¬…ï¸ è¿”å›", callback_data: "deps_main" }]);

  var text = typeName + " <b>ä¾èµ–</b>\n\nå…± " + deps.length + " ä¸ª";
  await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
}

// ==================== è„šæœ¬ç®¡ç† ====================

async function cmdScripts(chatId, userId, folder, page, env, msgId) {
  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var result = await qlApi(env, qlConfig, userId, "GET", "/open/scripts", null);
  if (result.code !== 200) {
    var text = "âŒ è·å–å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯");
    if (msgId) return await editMsg(env, chatId, msgId, text);
    return await sendMsg(env, chatId, text);
  }

  var data = result.data || [];
  var folders = [];
  var files = [];

  if (!folder) {
    for (var i = 0; i < data.length; i++) {
      var item = data[i];
      if (item.children && item.children.length > 0) {
        folders.push(item.title);
      } else if (item.title) {
        files.push(item.title);
      }
    }
  } else {
    var findNode = function(items, target) {
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (item.title === target) return item;
        if (item.children) {
          var found = findNode(item.children, target);
          if (found) return found;
        }
      }
      return null;
    };
    var node = findNode(data, folder);
    if (node && node.children) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children[i];
        if (child.children && child.children.length > 0) {
          folders.push(child.title);
        } else if (child.title) {
          files.push(child.title);
        }
      }
    }
  }

  var keyboard = [];
  if (folder) {
    keyboard.push([{ text: "â¬…ï¸ è¿”å›æ ¹ç›®å½•", callback_data: "scripts_root_0" }]);
  }

  for (var i = 0; i < folders.length; i++) {
    var fname = folders[i];
    keyboard.push([{ text: "ğŸ“‚ " + fname.slice(0, 28), callback_data: "sdir_" + encodeURIComponent(fname).slice(0, 50) }]);
  }

  var pageSize = 5;
  var totalPages = Math.max(1, Math.ceil(files.length / pageSize));
  var p = Math.min(Math.max(0, page), totalPages - 1);
  var pageFiles = files.slice(p * pageSize, (p + 1) * pageSize);

  for (var i = 0; i < pageFiles.length; i++) {
    var f = pageFiles[i];
    var displayName = f.length > 18 ? f.slice(0, 18) + ".." : f;
    var path = folder ? folder + "/" + f : f;
    var encodedPath = encodeURIComponent(path).slice(0, 40);
    keyboard.push([
      { text: "ğŸ“„ " + displayName, callback_data: "scrview_" + encodedPath },
      { text: "â–¶ï¸", callback_data: "scrrun_" + encodedPath },
      { text: "ğŸ—‘ï¸", callback_data: "scrdel_" + encodedPath }
    ]);
  }

  if (files.length > pageSize) {
    var nav = [];
    var folderParam = folder ? encodeURIComponent(folder).slice(0, 30) : "";
    if (p > 0) nav.push({ text: "â¬…ï¸", callback_data: "scrp_" + folderParam + "_" + (p - 1) });
    nav.push({ text: (p + 1) + "/" + totalPages, callback_data: "noop" });
    if (p < totalPages - 1) nav.push({ text: "â¡ï¸", callback_data: "scrp_" + folderParam + "_" + (p + 1) });
    keyboard.push(nav);
  }

  keyboard.push([{ text: "ğŸ”„ åˆ·æ–°", callback_data: folder ? "scr_refresh_" + encodeURIComponent(folder).slice(0, 40) : "scr_refresh_root" }]);

  var title = folder || "æ ¹ç›®å½•";
  var text = "ğŸ“ <b>è„šæœ¬ç®¡ç† - " + title + "</b>\n\nğŸ“‚ " + folders.length + " æ–‡ä»¶å¤¹ | ğŸ“„ " + files.length + " æ–‡ä»¶";

  if (msgId) return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: keyboard } });
  return await sendMsg(env, chatId, text, { reply_markup: { inline_keyboard: keyboard } });
}

async function sendScriptFile(chatId, msgId, path, userId, env) {
  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var lastSlash = path.lastIndexOf("/");
  var filename = lastSlash >= 0 ? path.slice(lastSlash + 1) : path;
  var dir = lastSlash >= 0 ? path.slice(0, lastSlash) : "";

  try {
    await editMsg(env, chatId, msgId, "â³ æ­£åœ¨è·å–: <code>" + escapeHtml(filename) + "</code>...");

    var endpoint = "/open/scripts/" + encodeURIComponent(filename) + "?path=" + encodeURIComponent(dir);
    var result = await qlApi(env, qlConfig, userId, "GET", endpoint, null);

    if (result.code !== 200 || !result.data) {
      throw new Error(result.message || "è·å–å¤±è´¥");
    }

    var content = result.data;
    var blob = new Blob([content], { type: "text/plain" });
    var formData = new FormData();
    formData.append("chat_id", String(chatId));
    formData.append("document", blob, filename);

    var sizeKB = (content.length / 1024).toFixed(2);
    var caption = "ğŸ“„ <b>" + escapeHtml(filename) + "</b>\n\n";
    caption += "ğŸ“ è·¯å¾„: <code>" + escapeHtml(path) + "</code>\n";
    caption += "ğŸ“ å¤§å°: " + content.length + " å­—èŠ‚ (" + sizeKB + " KB)";

    formData.append("caption", caption);
    formData.append("parse_mode", "HTML");

    var resp = await fetch("https://api.telegram.org/bot" + env.TG_BOT_TOKEN + "/sendDocument", {
      method: "POST",
      body: formData
    });

    var sendResult = await resp.json();
    if (!sendResult.ok) {
      throw new Error(sendResult.description || "å‘é€å¤±è´¥");
    }

    var encodedPath = encodeURIComponent(path).slice(0, 40);
    var kb = [
      [
        { text: "â–¶ï¸ æ·»åŠ ä»»åŠ¡", callback_data: "scrrun_" + encodedPath },
        { text: "ğŸ—‘ï¸ åˆ é™¤", callback_data: "scrdel_" + encodedPath }
      ],
      [
        { text: "ğŸ“¤ é‡æ–°å‘é€", callback_data: "scrview_" + encodedPath },
        { text: "â¬…ï¸ è¿”å›", callback_data: dir ? "sdir_" + encodeURIComponent(dir).slice(0, 50) : "scripts_root_0" }
      ]
    ];

    return await editMsg(env, chatId, msgId, "âœ… å·²å‘é€: <b>" + escapeHtml(filename) + "</b>", { reply_markup: { inline_keyboard: kb } });
  } catch (error) {
    var kb = [[{ text: "â¬…ï¸ è¿”å›", callback_data: "scripts_root_0" }]];
    return await editMsg(env, chatId, msgId, "âŒ å¤±è´¥: " + error.message, { reply_markup: { inline_keyboard: kb } });
  }
}

// ==================== æ–‡ä»¶å¤„ç† ====================

async function handleFileUrl(msg, env) {
  var chatId = msg.chat.id;
  var userId = msg.from.id;
  var url = (msg.text || "").trim();

  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var urlMatch = url.match(/https?:\/\/[^\s]+/i);
  if (!urlMatch) {
    return await sendMsg(env, chatId, "âŒ æ— æ³•è¯†åˆ«é“¾æ¥");
  }
  url = urlMatch[0];

  if (url.includes("github.com") && url.includes("/blob/")) {
    url = url.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/");
  }
  if (url.includes("gitee.com") && url.includes("/blob/")) {
    url = url.replace("/blob/", "/raw/");
  }

  var urlParts = url.split("/");
  var fileName = urlParts[urlParts.length - 1];
  if (fileName.includes("?")) {
    fileName = fileName.split("?")[0];
  }

  var validExts = [".js", ".py", ".sh", ".ts"];
  var lastDot = fileName.lastIndexOf(".");
  var ext = lastDot >= 0 ? fileName.slice(lastDot).toLowerCase() : "";

  if (validExts.indexOf(ext) < 0) {
    return await sendMsg(env, chatId, "âŒ ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: " + (ext || "æ— æ‰©å±•å"));
  }

  await sendMsg(env, chatId, "â³ æ­£åœ¨ä¸‹è½½: " + fileName);

  try {
    var fileResp = await fetch(url, { headers: { "User-Agent": "Mozilla/5.0" } });
    if (!fileResp.ok) throw new Error("ä¸‹è½½å¤±è´¥: HTTP " + fileResp.status);

    var content = await fileResp.text();
    if (content.length > 1024 * 1024) throw new Error("æ–‡ä»¶è¿‡å¤§ (æœ€å¤§ 1MB)");

    var uploadResult = await qlApi(env, qlConfig, userId, "POST", "/open/scripts", {
      filename: fileName,
      content: content,
      path: ""
    });

    if (uploadResult.code !== 200) throw new Error(uploadResult.message || "ä¸Šä¼ å¤±è´¥");

    var kb = { inline_keyboard: [[
      { text: "âœ… åˆ›å»ºå®šæ—¶ä»»åŠ¡", callback_data: "newcron_" + encodeURIComponent(fileName) },
      { text: "âŒ ä»…ä¿å­˜", callback_data: "noop" }
    ]] };

    await sendMsg(env, chatId, "âœ… <b>" + fileName + "</b> ä¸Šä¼ æˆåŠŸï¼\n\næ˜¯å¦åˆ›å»ºå®šæ—¶ä»»åŠ¡ï¼Ÿ", { reply_markup: kb });
  } catch (error) {
    await sendMsg(env, chatId, "âŒ å¤„ç†å¤±è´¥: " + error.message);
  }
}

async function handleDocument(msg, env) {
  var chatId = msg.chat.id;
  var userId = msg.from.id;
  var doc = msg.document;
  var fileName = doc.file_name;

  var qlConfig = getQlConfigForUser(env, userId);
  if (!qlConfig) return;

  var validExts = [".js", ".py", ".sh", ".ts"];
  var lastDot = fileName.lastIndexOf(".");
  var ext = lastDot >= 0 ? fileName.slice(lastDot).toLowerCase() : "";

  if (validExts.indexOf(ext) < 0) {
    return await sendMsg(env, chatId, "âŒ ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ " + ext);
  }

  if (doc.file_size > 1024 * 1024) {
    return await sendMsg(env, chatId, "âŒ æ–‡ä»¶è¿‡å¤§ (æœ€å¤§ 1MB)");
  }

  await sendMsg(env, chatId, "â³ æ­£åœ¨ä¸Šä¼ : " + fileName);

  try {
    var fileInfo = await tgApi(env.TG_BOT_TOKEN, "getFile", { file_id: doc.file_id });
    if (!fileInfo.ok) throw new Error("è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥");

    var fileUrl = "https://api.telegram.org/file/bot" + env.TG_BOT_TOKEN + "/" + fileInfo.result.file_path;
    var fileResp = await fetch(fileUrl);
    var content = await fileResp.text();

    var uploadResult = await qlApi(env, qlConfig, userId, "POST", "/open/scripts", {
      filename: fileName,
      content: content,
      path: ""
    });

    if (uploadResult.code !== 200) throw new Error(uploadResult.message || "ä¸Šä¼ å¤±è´¥");

    var kb = { inline_keyboard: [[
      { text: "âœ… åˆ›å»ºå®šæ—¶ä»»åŠ¡", callback_data: "newcron_" + encodeURIComponent(fileName) },
      { text: "âŒ ä»…ä¿å­˜", callback_data: "noop" }
    ]] };

    await sendMsg(env, chatId, "âœ… <b>" + fileName + "</b> ä¸Šä¼ æˆåŠŸï¼\n\næ˜¯å¦åˆ›å»ºå®šæ—¶ä»»åŠ¡ï¼Ÿ", { reply_markup: kb });
  } catch (error) {
    await sendMsg(env, chatId, "âŒ ä¸Šä¼ å¤±è´¥: " + error.message);
  }
}

// ==================== å›è°ƒå¤„ç† ====================

async function handleCallback(cb, env) {
  var chatId = cb.message.chat.id;
  var msgId = cb.message.message_id;
  var userId = cb.from.id;
  var data = cb.data;

  console.log("Callback:", data, "from", userId);
  await answerCb(env, cb.id, "â³ å¤„ç†ä¸­...");

  if (data === "noop") return;

  var qlConfig = getQlConfigForUser(env, userId);

  // å¸®åŠ©æŒ‰é’®å¿«æ·å‘½ä»¤
  if (data === "cmd_tasks") {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return await cmdTasks(chatId, userId, 0, env, null);
  }
  if (data === "cmd_envs") {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return await cmdEnvs(chatId, userId, 0, env, null);
  }
  if (data === "cmd_subs") {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return await cmdSubs(chatId, userId, 0, env, null);
  }
  if (data === "cmd_deps") {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return await cmdDeps(chatId, userId, env, null);
  }
  if (data === "cmd_scripts") {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return await cmdScripts(chatId, userId, "", 0, env, null);
  }
  if (data === "cmd_users") {
    if (!isAdmin(userId, env)) {
      return await sendMsg(env, chatId, "â›” ä»…ç®¡ç†å‘˜å¯ç”¨");
    }
    return await cmdUsers(chatId, 0, env, null);
  }

  // è®¾ç½®æµç¨‹
  if (data === "setup_start") {
    userStates.set(userId, { action: "setup_url", chatId: chatId, msgId: msgId });
    return await editMsg(env, chatId, msgId,
      "ğŸ”§ <b>é…ç½®é’é¾™é¢æ¿ (1/4)</b>\n\nè¯·è¾“å…¥æ‚¨çš„é’é¾™é¢æ¿åœ°å€\nä¾‹: <code>http://192.168.1.100:5700</code>\n\n/cancel å–æ¶ˆ"
    );
  }

  // åˆ é™¤æˆ‘çš„é…ç½®
  if (data === "delete_my_config") {
    var kb = { inline_keyboard: [
      [{ text: "âœ… ç¡®è®¤åˆ é™¤", callback_data: "confirm_delete_config" }],
      [{ text: "âŒ å–æ¶ˆ", callback_data: "cancel_delete" }]
    ] };
    return await editMsg(env, chatId, msgId, "âš ï¸ ç¡®å®šè¦åˆ é™¤æ‚¨çš„é…ç½®å—ï¼Ÿ\n\nåˆ é™¤åéœ€è¦é‡æ–°æ·»åŠ ", { reply_markup: kb });
  }

  if (data === "confirm_delete_config") {
    await deleteUserConfig(env, userId);
    userSessions.delete(String(userId));
    return await editMsg(env, chatId, msgId, "âœ… é…ç½®å·²åˆ é™¤");
  }

  if (data === "cancel_delete") {
    return await cmdMyConfig(chatId, userId, env);
  }

  // æµ‹è¯•è¿æ¥
  if (data === "test_connection") {
    var testConfig = getQlConfigForUser(env, userId);
    if (!testConfig) {
      return await sendMsg(env, chatId, "âŒ è¯·å…ˆè§£é”æˆ–é…ç½®é’é¾™é¢æ¿");
    }
    try {
      await getQlToken(env, testConfig, userId);
      return await sendMsg(env, chatId, "âœ… è¿æ¥æˆåŠŸï¼");
    } catch (e) {
      return await sendMsg(env, chatId, "âŒ è¿æ¥å¤±è´¥: " + e.message);
    }
  }

  // ç”¨æˆ·ç®¡ç†
  if (data === "users_refresh") {
    return await cmdUsers(chatId, 0, env, msgId);
  }
  if (data.startsWith("users_")) {
    var page = parseInt(data.slice(6)) || 0;
    return await cmdUsers(chatId, page, env, msgId);
  }
  if (data.startsWith("user_ban_")) {
    var targetId = data.slice(9);
    var config = await getUserConfig(env, targetId);
    if (config) {
      config.banned = true;
      await saveUserConfig(env, targetId, config);
    }
    return await showUserDetail(chatId, msgId, targetId, env);
  }
  if (data.startsWith("user_unban_")) {
    var targetId = data.slice(11);
    var config = await getUserConfig(env, targetId);
    if (config) {
      config.banned = false;
      await saveUserConfig(env, targetId, config);
    }
    return await showUserDetail(chatId, msgId, targetId, env);
  }
  if (data.startsWith("user_del_")) {
    var targetId = data.slice(9);
    await deleteUserConfig(env, targetId);
    userSessions.delete(targetId);
    return await cmdUsers(chatId, 0, env, msgId);
  }
  if (data.startsWith("user_")) {
    var targetId = data.slice(5);
    return await showUserDetail(chatId, msgId, targetId, env);
  }

  // éœ€è¦é’é¾™é…ç½®çš„æ“ä½œ
  if (!qlConfig) {
    if (!await checkUserAccess(env, chatId, userId)) return;
    return;
  }

  // ä»»åŠ¡æ“ä½œ
  if (data.startsWith("tasks_refresh_")) {
    var page = parseInt(data.slice(14)) || 0;
    return await cmdTasks(chatId, userId, page, env, msgId);
  }
  if (data.startsWith("tasks_")) {
    var page = parseInt(data.slice(6)) || 0;
    return await cmdTasks(chatId, userId, page, env, msgId);
  }
  if (data.startsWith("cron_run_")) {
    var id = data.slice(9);
    await qlApi(env, qlConfig, userId, "PUT", "/open/crons/run", [parseInt(id)]);
    return await showCron(chatId, msgId, id, userId, env);
  }
  if (data.startsWith("cron_stop_")) {
    var id = data.slice(10);
    await qlApi(env, qlConfig, userId, "PUT", "/open/crons/stop", [parseInt(id)]);
    return await showCron(chatId, msgId, id, userId, env);
  }
  if (data.startsWith("cron_en_")) {
    var id = data.slice(8);
    await qlApi(env, qlConfig, userId, "PUT", "/open/crons/enable", [parseInt(id)]);
    return await showCron(chatId, msgId, id, userId, env);
  }
  if (data.startsWith("cron_dis_")) {
    var id = data.slice(9);
    await qlApi(env, qlConfig, userId, "PUT", "/open/crons/disable", [parseInt(id)]);
    return await showCron(chatId, msgId, id, userId, env);
  }
  if (data.startsWith("cron_del_")) {
    var id = data.slice(9);
    await qlApi(env, qlConfig, userId, "DELETE", "/open/crons", [parseInt(id)]);
    return await cmdTasks(chatId, userId, 0, env, msgId);
  }
  if (data.startsWith("cron_edit_")) {
    var id = data.slice(10);
    userStates.set(userId, { action: "edit_cron", cronId: id, chatId: chatId, msgId: msgId });
    return await editMsg(env, chatId, msgId,
      "âœï¸ <b>ç¼–è¾‘å®šæ—¶</b>\n\nè¯·è¾“å…¥æ–°çš„ cron è¡¨è¾¾å¼\nä¾‹: <code>0 8 * * *</code>\n\n/cancel å–æ¶ˆ",
      { reply_markup: { inline_keyboard: [[{ text: "âŒ å–æ¶ˆ", callback_data: "cron_" + id }]] } }
    );
  }
  if (data.startsWith("cron_log_")) {
    var id = data.slice(9);
    var logRes = await qlApi(env, qlConfig, userId, "GET", "/open/crons/" + id + "/log", null);
    var logContent = logRes.code === 200 ? (logRes.data || "æš‚æ— æ—¥å¿—") : "è·å–æ—¥å¿—å¤±è´¥";
    if (logContent.length > 3000) {
      logContent = "...(å·²æˆªå–)\n" + logContent.slice(-3000);
    }
    var text = "ğŸ“„ <b>ä»»åŠ¡æ—¥å¿—</b>\n\n<pre>" + escapeHtml(logContent) + "</pre>";
    var kb = [[
      { text: "ğŸ”„ åˆ·æ–°", callback_data: "cron_log_" + id },
      { text: "â¬…ï¸ è¿”å›", callback_data: "cron_" + id }
    ]];
    return await editMsg(env, chatId, msgId, text, { reply_markup: { inline_keyboard: kb } });
  }
  if (data === "task_new") {
    userStates.set(userId, { action: "new_cron", chatId: chatId, msgId: msgId });
    return await editMsg(env, chatId, msgId,
      "â• <b>æ–°å»ºä»»åŠ¡</b>\n\næ ¼å¼: <code>åç§°|å‘½ä»¤|å®šæ—¶</code>\nä¾‹: <code>æµ‹è¯•|task test.js|0 8 * * *</code>\n\n/cancel å–æ¶ˆ",
      { reply_markup: { inline_keyboard: [[{ text: "âŒ å–æ¶ˆ", callback_data: "tasks_0" }]] } }
    );
  }
  if (data.startsWith("cron_")) {
    var id = data.slice(5);
    return await showCron(chatId, msgId, id, userId, env);
  }
  if (data.startsWith("newcron_")) {
    var fileName = decodeURIComponent(data.slice(8));
    userStates.set(userId, { action: "create_cron", fileName: fileName, chatId: chatId, msgId: msgId });
    return await sendMsg(env, chatId,
      "â° ä¸º <b>" + fileName + "</b> è®¾ç½®å®šæ—¶\n\nè¾“å…¥ cron è¡¨è¾¾å¼\næˆ–è¾“å…¥ <code>d</code> ä½¿ç”¨é»˜è®¤(æ¯å¤©0ç‚¹)\n\n/cancel å–æ¶ˆ"
    );
  }

  // ç¯å¢ƒå˜é‡æ“ä½œ
  if (data.startsWith("envs_refresh_")) {
    var page = parseInt(data.slice(13)) || 0;
    return await cmdEnvs(chatId, userId, page, env, msgId);
  }
  if (data.startsWith("envs_")) {
    var page = parseInt(data.slice(5)) || 0;
    return await cmdEnvs(chatId, userId, page, env, msgId);
  }
  if (data.startsWith("env_en_")) {
    var id = data.slice(7);
    await qlApi(env, qlConfig, userId, "PUT", "/open/envs/enable", [parseInt(id)]);
    return await showEnv(chatId, msgId, id, userId, env);
  }
  if (data.startsWith("env_dis_")) {
    var id = data.slice(8);
    await qlApi(env, qlConfig, userId, "PUT", "/open/envs/disable", [parseInt(id)]);
    return await showEnv(chatId, msgId, id, userId, env);
  }
  if (data.startsWith("env_del_")) {
    var id = data.slice(8);
    await qlApi(env, qlConfig, userId, "DELETE", "/open/envs", [parseInt(id)]);
    return await cmdEnvs(chatId, userId, 0, env, msgId);
  }
  if (data === "env_add") {
    userStates.set(userId, { action: "add_env", chatId: chatId, msgId: msgId });
    return await editMsg(env, chatId, msgId,
      "â• <b>æ·»åŠ å˜é‡</b>\n\næ ¼å¼: <code>åç§°=å€¼</code>\n\n/cancel å–æ¶ˆ",
      { reply_markup: { inline_keyboard: [[{ text: "âŒ å–æ¶ˆ", callback_data: "envs_0" }]] } }
    );
  }
  if (data.startsWith("env_edit_")) {
    var id = data.slice(9);
    userStates.set(userId, { action: "edit_env", envId: id, chatId: chatId, msgId: msgId });
    return await editMsg(env, chatId, msgId,
      "âœï¸ <b>ç¼–è¾‘å˜é‡</b>\n\næ ¼å¼: <code>åç§°=å€¼</code>\n\n/cancel å–æ¶ˆ",
      { reply_markup: { inline_keyboard: [[{ text: "âŒ å–æ¶ˆ", callback_data: "env_" + id }]] } }
    );
  }
  if (data.startsWith("env_")) {
    var id = data.slice(4);
    return await showEnv(chatId, msgId, id, userId, env);
  }

  // è®¢é˜…æ“ä½œ
  if (data.startsWith("subs_refresh_")) {
    var page = parseInt(data.slice(13)) || 0;
    return await cmdSubs(chatId, userId, page, env, msgId);
  }
  if (data.startsWith("subs_")) {
    var page = parseInt(data.slice(5)) || 0;
    return await cmdSubs(chatId, userId, page, env, msgId);
  }
  if (data.startsWith("sub_run_")) {
    var id = data.slice(8);
    await qlApi(env, qlConfig, userId, "PUT", "/open/subscriptions/run", [parseInt(id)]);
    return await showSub(chatId, msgId, id, userId, env);
  }
  if (data.startsWith("sub_en_")) {
    var id = data.slice(7);
    await qlApi(env, qlConfig, userId, "PUT", "/open/subscriptions/enable", [parseInt(id)]);
    return await showSub(chatId, msgId, id, userId, env);
  }
  if (data.startsWith("sub_dis_")) {
    var id = data.slice(8);
    await qlApi(env, qlConfig, userId, "PUT", "/open/subscriptions/disable", [parseInt(id)]);
    return await showSub(chatId, msgId, id, userId, env);
  }
  if (data.startsWith("sub_del_")) {
    var id = data.slice(8);
    await qlApi(env, qlConfig, userId, "DELETE", "/open/subscriptions", [parseInt(id)]);
    return await cmdSubs(chatId, userId, 0, env, msgId);
  }
  if (data === "sub_add") {
    userStates.set(userId, { action: "add_sub", chatId: chatId, msgId: msgId });
    return await editMsg(env, chatId, msgId,
      "â• <b>æ·»åŠ è®¢é˜…</b>\n\næ ¼å¼: <code>åç§°|URL|å®šæ—¶|åˆ†æ”¯</code>\n\n/cancel å–æ¶ˆ",
      { reply_markup: { inline_keyboard: [[{ text: "âŒ å–æ¶ˆ", callback_data: "subs_0" }]] } }
    );
  }
  if (data.startsWith("sub_")) {
    var id = data.slice(4);
    return await showSub(chatId, msgId, id, userId, env);
  }

  // ä¾èµ–æ“ä½œ
  if (data === "deps_refresh") {
    return await cmdDeps(chatId, userId, env, msgId);
  }
  if (data === "deps_main") {
    return await cmdDeps(chatId, userId, env, msgId);
  }
  if (data.startsWith("dep_list_")) {
    var type = data.slice(9);
    return await showDepList(chatId, msgId, type, 0, userId, env);
  }
  if (data.startsWith("dep_page_")) {
    var rest = data.slice(9);
    var parts = rest.split("_");
    var type = parts[0];
    var page = parseInt(parts[1]) || 0;
    return await showDepList(chatId, msgId, type, page, userId, env);
  }
  if (data.startsWith("dep_refresh_")) {
    var type = data.slice(12);
    return await showDepList(chatId, msgId, type, 0, userId, env);
  }
  if (data.startsWith("dep_reinstall_")) {
    var rest = data.slice(14);
    var parts = rest.split("_");
    var id = parts[0];
    var type = parts[1];
    await qlApi(env, qlConfig, userId, "PUT", "/open/dependencies/reinstall", [parseInt(id)]);
    return await showDepList(chatId, msgId, type, 0, userId, env);
  }
  if (data.startsWith("dep_del_")) {
    var rest = data.slice(8);
    var parts = rest.split("_");
    var id = parts[0];
    var type = parts[1];
    await qlApi(env, qlConfig, userId, "DELETE", "/open/dependencies", [parseInt(id)]);
    return await showDepList(chatId, msgId, type, 0, userId, env);
  }
  if (data.startsWith("dep_add_")) {
    var type = data.slice(8);
    userStates.set(userId, { action: "add_dep", type: type, chatId: chatId, msgId: msgId });
    var typeNames = { python3: "Python", nodejs: "Node.js", linux: "Linux" };
    return await editMsg(env, chatId, msgId,
      "â• <b>æ·»åŠ  " + (typeNames[type] || type) + " ä¾èµ–</b>\n\nè¾“å…¥ä¾èµ–åï¼ˆç©ºæ ¼åˆ†éš”ï¼‰\n\n/cancel å–æ¶ˆ",
      { reply_markup: { inline_keyboard: [[{ text: "âŒ å–æ¶ˆ", callback_data: "dep_list_" + type }]] } }
    );
  }

  // è„šæœ¬æ“ä½œ
  if (data.startsWith("scripts_root_")) {
    var page = parseInt(data.slice(13)) || 0;
    return await cmdScripts(chatId, userId, "", page, env, msgId);
  }
  if (data.startsWith("sdir_")) {
    var folder = decodeURIComponent(data.slice(5));
    return await cmdScripts(chatId, userId, folder, 0, env, msgId);
  }
  if (data.startsWith("scrp_")) {
    var rest = data.slice(5);
    var lastUnderscore = rest.lastIndexOf("_");
    var folderEncoded = rest.slice(0, lastUnderscore);
    var page = parseInt(rest.slice(lastUnderscore + 1)) || 0;
    var folder = folderEncoded ? decodeURIComponent(folderEncoded) : "";
    return await cmdScripts(chatId, userId, folder, page, env, msgId);
  }
  if (data.startsWith("scr_refresh_")) {
    var folderPart = data.slice(12);
    var folder = folderPart === "root" ? "" : decodeURIComponent(folderPart);
    return await cmdScripts(chatId, userId, folder, 0, env, msgId);
  }
  if (data.startsWith("scrview_")) {
    var path = decodeURIComponent(data.slice(8));
    return await sendScriptFile(chatId, msgId, path, userId, env);
  }
  if (data.startsWith("scrrun_")) {
    var path = decodeURIComponent(data.slice(7));
    var lastSlash = path.lastIndexOf("/");
    var filename = lastSlash >= 0 ? path.slice(lastSlash + 1) : path;
    userStates.set(userId, { action: "add_script_cron", filename: filename, path: path, chatId: chatId, msgId: msgId });
    return await editMsg(env, chatId, msgId,
      "â° <b>æ·»åŠ åˆ°è¿è¡Œåˆ—è¡¨</b>\n\nè„šæœ¬: <code>" + filename + "</code>\n\nè¯·è¾“å…¥ cron è¡¨è¾¾å¼\næˆ–è¾“å…¥ <code>d</code> ä½¿ç”¨é»˜è®¤(æ¯å¤©0ç‚¹)\n\n/cancel å–æ¶ˆ",
      { reply_markup: { inline_keyboard: [[{ text: "âŒ å–æ¶ˆ", callback_data: "scripts_root_0" }]] } }
    );
  }
  if (data.startsWith("scrdel_")) {
    var path = decodeURIComponent(data.slice(7));
    var lastSlash = path.lastIndexOf("/");
    var filename = lastSlash >= 0 ? path.slice(lastSlash + 1) : path;
    var dir = lastSlash >= 0 ? path.slice(0, lastSlash) : "";
    await qlApi(env, qlConfig, userId, "DELETE", "/open/scripts", { filename: filename, path: dir });
    return await cmdScripts(chatId, userId, dir, 0, env, msgId);
  }

  console.log("Unhandled callback:", data);
}

// ==================== çŠ¶æ€è¾“å…¥å¤„ç† ====================

async function handleStateInput(msg, state, env) {
  var chatId = msg.chat.id;
  var userId = msg.from.id;
  var text = (msg.text || "").trim();
  var msgId = state.msgId;

  if (text === "/cancel") {
    userStates.delete(userId);
    return await sendMsg(env, chatId, "âŒ å·²å–æ¶ˆ");
  }

  try {
    // è®¾ç½®æµç¨‹
    if (state.action === "setup_url") {
      if (!text.startsWith("http")) {
        return await sendMsg(env, chatId, "âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„ URLï¼Œä»¥ http:// æˆ– https:// å¼€å¤´");
      }
      state.ql_base_url = text.replace(/\/$/, "");
      state.action = "setup_client_id";
      userStates.set(userId, state);
      return await sendMsg(env, chatId,
        "ğŸ”§ <b>é…ç½®é’é¾™é¢æ¿ (2/4)</b>\n\nè¯·è¾“å…¥ Client ID\n\n/cancel å–æ¶ˆ"
      );
    }

    if (state.action === "setup_client_id") {
      state.ql_client_id = text;
      state.action = "setup_client_secret";
      userStates.set(userId, state);
      return await sendMsg(env, chatId,
        "ğŸ”§ <b>é…ç½®é’é¾™é¢æ¿ (3/4)</b>\n\nè¯·è¾“å…¥ Client Secret\n\n/cancel å–æ¶ˆ"
      );
    }

    if (state.action === "setup_client_secret") {
      state.ql_client_secret = text;
      state.action = "setup_pin";
      userStates.set(userId, state);
      return await sendMsg(env, chatId,
        "ğŸ”§ <b>é…ç½®é’é¾™é¢æ¿ (4/4)</b>\n\nè¯·è®¾ç½® 6 ä½æ•°å­— PIN ç \nç”¨äºåŠ å¯†æ‚¨çš„å‡­è¯\n\nâš ï¸ PIN ä¸ä¼šå­˜å‚¨ï¼Œè¯·ç‰¢è®°ï¼\n\n/cancel å–æ¶ˆ"
      );
    }

    if (state.action === "setup_pin") {
      if (!/^\d{6}$/.test(text)) {
        return await sendMsg(env, chatId, "âŒ PIN å¿…é¡»æ˜¯ 6 ä½æ•°å­—");
      }

      var testConfig = {
        baseUrl: state.ql_base_url,
        clientId: state.ql_client_id,
        clientSecret: state.ql_client_secret
      };

      try {
        await getQlToken(env, testConfig, userId);
      } catch (e) {
        userStates.delete(userId);
        return await sendMsg(env, chatId, "âŒ è¿æ¥å¤±è´¥: " + e.message + "\n\nè¯·æ£€æŸ¥é…ç½®åé‡è¯•");
      }

      var encrypted = await encryptData(testConfig, text, userId);
      await saveUserConfig(env, userId, {
        encrypted: encrypted,
        createdAt: Date.now(),
        banned: false
      });

      userSessions.set(String(userId), {
        qlConfig: testConfig,
        expiry: Date.now() + SESSION_TIMEOUT
      });

      userStates.delete(userId);
      return await sendMsg(env, chatId,
        "âœ… <b>é…ç½®æˆåŠŸï¼</b>\n\næ‚¨çš„é’é¾™é¢æ¿å·²æ·»åŠ \nä¼šè¯æœ‰æ•ˆæœŸ 30 åˆ†é’Ÿ\n\nä½¿ç”¨ /start å¼€å§‹æ“ä½œ"
      );
    }

    // è§£é” PIN
    if (state.action === "unlock_pin") {
      var config = await getUserConfig(env, userId);
      if (!config) {
        userStates.delete(userId);
        return await sendMsg(env, chatId, "âŒ é…ç½®ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°æ·»åŠ ");
      }

      var decrypted = await decryptData(config.encrypted, text, userId);
      if (!decrypted) {
        return await sendMsg(env, chatId, "âŒ PIN é”™è¯¯ï¼Œè¯·é‡è¯•\n\n/cancel å–æ¶ˆ");
      }

      userSessions.set(String(userId), {
        qlConfig: decrypted,
        expiry: Date.now() + SESSION_TIMEOUT
      });

      userStates.delete(userId);
      return await sendMsg(env, chatId, "ğŸ”“ è§£é”æˆåŠŸï¼\n\nä½¿ç”¨ /start å¼€å§‹æ“ä½œ");
    }

    // ä»¥ä¸‹éœ€è¦é’é¾™é…ç½®
    var qlConfig = getQlConfigForUser(env, userId);
    if (!qlConfig) {
      userStates.delete(userId);
      return await sendMsg(env, chatId, "âŒ ä¼šè¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°è§£é”");
    }

    // ç¼–è¾‘å®šæ—¶
    if (state.action === "edit_cron") {
      var cronRes = await qlApi(env, qlConfig, userId, "GET", "/open/crons/" + state.cronId, null);
      if (cronRes.code !== 200 || !cronRes.data) {
        userStates.delete(userId);
        return await sendMsg(env, chatId, "âŒ ä»»åŠ¡ä¸å­˜åœ¨");
      }
      var cron = cronRes.data;
      var result = await qlApi(env, qlConfig, userId, "PUT", "/open/crons", {
        id: parseInt(state.cronId),
        name: cron.name,
        command: cron.command,
        schedule: text,
        labels: cron.labels || []
      });
      userStates.delete(userId);
      if (result.code === 200) {
        await sendMsg(env, chatId, "âœ… å®šæ—¶å·²æ›´æ–°ä¸º: <code>" + text + "</code>");
        return await showCron(chatId, msgId, state.cronId, userId, env);
      }
      return await sendMsg(env, chatId, "âŒ æ›´æ–°å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }

    // åˆ›å»ºä»»åŠ¡ï¼ˆä»è„šæœ¬ï¼‰
    if (state.action === "create_cron") {
      var schedule = text.toLowerCase() === "d" ? "0 0 * * *" : text;
      var result = await qlApi(env, qlConfig, userId, "POST", "/open/crons", {
        name: state.fileName,
        command: "task " + state.fileName,
        schedule: schedule
      });
      userStates.delete(userId);
      if (result.code === 200) {
        return await sendMsg(env, chatId, "âœ… ä»»åŠ¡å·²åˆ›å»º\n\nåç§°: <code>" + state.fileName + "</code>\nå®šæ—¶: <code>" + schedule + "</code>");
      }
      return await sendMsg(env, chatId, "âŒ åˆ›å»ºå¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }

    // æ–°å»ºä»»åŠ¡
    if (state.action === "new_cron") {
      var parts = text.split("|");
      if (parts.length < 3) {
        return await sendMsg(env, chatId, "âŒ æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨: åç§°|å‘½ä»¤|å®šæ—¶");
      }
      var result = await qlApi(env, qlConfig, userId, "POST", "/open/crons", {
        name: parts[0].trim(),
        command: parts[1].trim(),
        schedule: parts[2].trim()
      });
      userStates.delete(userId);
      if (result.code === 200) {
        await sendMsg(env, chatId, "âœ… ä»»åŠ¡åˆ›å»ºæˆåŠŸ");
        return await cmdTasks(chatId, userId, 0, env, null);
      }
      return await sendMsg(env, chatId, "âŒ åˆ›å»ºå¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }

    // æ·»åŠ ç¯å¢ƒå˜é‡
    if (state.action === "add_env") {
      var eqIndex = text.indexOf("=");
      if (eqIndex < 0) {
        return await sendMsg(env, chatId, "âŒ æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨: åç§°=å€¼");
      }
      var result = await qlApi(env, qlConfig, userId, "POST", "/open/envs", [{
        name: text.slice(0, eqIndex).trim(),
        value: text.slice(eqIndex + 1).trim()
      }]);
      userStates.delete(userId);
      if (result.code === 200) {
        await sendMsg(env, chatId, "âœ… å˜é‡æ·»åŠ æˆåŠŸ");
        return await cmdEnvs(chatId, userId, 0, env, null);
      }
      return await sendMsg(env, chatId, "âŒ æ·»åŠ å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }

    // ç¼–è¾‘ç¯å¢ƒå˜é‡
    if (state.action === "edit_env") {
      var eqIndex = text.indexOf("=");
      if (eqIndex < 0) {
        return await sendMsg(env, chatId, "âŒ æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨: åç§°=å€¼");
      }
      var envsRes = await qlApi(env, qlConfig, userId, "GET", "/open/envs", null);
      var envs = toArray(envsRes);
      var origEnv = envs.find(function(x) { return String(x.id) === String(state.envId); });

      var result = await qlApi(env, qlConfig, userId, "PUT", "/open/envs", {
        id: parseInt(state.envId),
        name: text.slice(0, eqIndex).trim(),
        value: text.slice(eqIndex + 1).trim(),
        remarks: origEnv ? origEnv.remarks : ""
      });
      userStates.delete(userId);
      if (result.code === 200) {
        await sendMsg(env, chatId, "âœ… å˜é‡å·²æ›´æ–°");
        return await showEnv(chatId, msgId, state.envId, userId, env);
      }
      return await sendMsg(env, chatId, "âŒ æ›´æ–°å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }

    // æ·»åŠ è®¢é˜…
    if (state.action === "add_sub") {
      var parts = text.split("|");
      if (parts.length < 2) {
        return await sendMsg(env, chatId, "âŒ æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨: åç§°|URL|å®šæ—¶|åˆ†æ”¯");
      }
      var body = {
        name: parts[0].trim(),
        url: parts[1].trim(),
        schedule: parts[2] ? parts[2].trim() : "0 0 * * *",
        type: "public-repo"
      };
      if (parts[3]) body.branch = parts[3].trim();
      var result = await qlApi(env, qlConfig, userId, "POST", "/open/subscriptions", body);
      userStates.delete(userId);
      if (result.code === 200) {
        await sendMsg(env, chatId, "âœ… è®¢é˜…æ·»åŠ æˆåŠŸ");
        return await cmdSubs(chatId, userId, 0, env, null);
      }
      return await sendMsg(env, chatId, "âŒ æ·»åŠ å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }

    // æ·»åŠ ä¾èµ–
    if (state.action === "add_dep") {
      var depNames = text.split(/\s+/);
      var typeMap = { python3: 0, nodejs: 1, linux: 2 };
      var body = depNames.filter(function(n) { return n.trim(); }).map(function(n) {
        return { name: n.trim(), type: typeMap[state.type] };
      });
      if (body.length === 0) {
        return await sendMsg(env, chatId, "âŒ è¯·è¾“å…¥ä¾èµ–åç§°");
      }
      var result = await qlApi(env, qlConfig, userId, "POST", "/open/dependencies", body);
      userStates.delete(userId);
      if (result.code === 200) {
        await sendMsg(env, chatId, "âœ… ä¾èµ–æ·»åŠ æˆåŠŸ");
        return await showDepList(chatId, msgId, state.type, 0, userId, env);
      }
      return await sendMsg(env, chatId, "âŒ æ·»åŠ å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }

    // æ·»åŠ è„šæœ¬ä»»åŠ¡
    if (state.action === "add_script_cron") {
      var schedule = text.toLowerCase() === "d" ? "0 0 * * *" : text;
      var result = await qlApi(env, qlConfig, userId, "POST", "/open/crons", {
        name: state.filename,
        command: "task " + state.path,
        schedule: schedule
      });
      userStates.delete(userId);
      if (result.code === 200) {
        await sendMsg(env, chatId, "âœ… å·²æ·»åŠ åˆ°è¿è¡Œåˆ—è¡¨\n\nè„šæœ¬: <code>" + state.filename + "</code>\nå®šæ—¶: <code>" + schedule + "</code>");
        return await cmdScripts(chatId, userId, "", 0, env, null);
      }
      return await sendMsg(env, chatId, "âŒ æ·»åŠ å¤±è´¥: " + (result.message || "æœªçŸ¥é”™è¯¯"));
    }

  } catch (error) {
    userStates.delete(userId);
    return await sendMsg(env, chatId, "âŒ é”™è¯¯: " + error.message);
  }
}
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      var codeTemplate = document.getElementById('code-template');
      var fullCode = codeTemplate.textContent.trim();
      document.getElementById('full-code').textContent = fullCode;
      hljs.highlightAll();
      
      window.fullCodeContent = fullCode;
    });

    function showTab(tabName) {
      document.querySelectorAll('[id^="content-"]').forEach(function(el) {
        el.classList.add('hidden');
      });
      document.querySelectorAll('[id^="tab-"]').forEach(function(el) {
        el.classList.remove('tab-active');
        el.classList.add('text-gray-400');
      });
      document.getElementById('content-' + tabName).classList.remove('hidden');
      var tab = document.getElementById('tab-' + tabName);
      tab.classList.add('tab-active');
      tab.classList.remove('text-gray-400');
    }

    function copyCode() {
      var code = window.fullCodeContent;
      navigator.clipboard.writeText(code).then(function() {
        var btn = event.target;
        btn.textContent = 'âœ… å·²å¤åˆ¶!';
        btn.classList.replace('bg-blue-600', 'bg-green-600');
        setTimeout(function() {
          btn.textContent = 'ğŸ“‹ å¤åˆ¶ä»£ç ';
          btn.classList.replace('bg-green-600', 'bg-blue-600');
        }, 2000);
      });
    }
  </script>
</body>
</html>